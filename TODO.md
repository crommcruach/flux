# Py_artnet - TODO Liste

## Geplante Features

### Architektur-Refactoring
- [ ] **HOCH: PlayerManager Refactoring (Analyse 2025-11-22)**
  - **Problem:** DMXController wird als Player-Container missbraucht
    - Verletzt Single Responsibility Principle
    - Namens-Verwirrung: Module nutzen `dmx_controller` nur für `player`-Zugriff
    - Zirkuläre Abhängigkeiten und Code-Duplikation
  - **Lösung:** PlayerManager-Klasse einführen
    - Zentraler Player-Container (Single Source of Truth)
    - DMXController bleibt rein für DMX-Input zuständig
    - Betrifft: main.py, cli_handler.py, rest_api.py, api_videos.py, command_executor.py
  - **Vorteile:**
    - Klare Verantwortlichkeit und Modulgrenzen
    - Einfacherer Player-Wechsel (nur `player_manager.set_player()`)
    - Reduziert Coupling zwischen Modulen
    - Bessere Testbarkeit

### Art-Net Optimierung
- [ ] **HOCH: Delta-Encoding für Art-Net Output (Konzept 2025-11-22)**
  - **Grundidee:** Sende nur Pixel die sich signifikant geändert haben
  - **Phase 0: LED Bit-Tiefe Unterstützung**
    - Parametrierbare Dimming-Modi: 8-bit (Standard) vs. 16-bit (High-End)
    - Config: `artnet.bit_depth` (8 oder 16)
    - **8-bit Modus:** 3 Bytes/LED (R, G, B je 0-255)
      - Standard für Consumer-LEDs (WS2812B, SK6812)
      - Ausreichend für 99% der Anwendungen
      - Threshold-Empfehlung: 5-10 (≈ 2-4%)
    - **16-bit Modus:** 6 Bytes/LED (R, G, B je 0-65535, High+Low Byte)
      - Professionelle LED-Systeme (DMX High-Resolution)
      - Smoother Dimming bei sehr niedrigen Helligkeiten
      - Threshold-Empfehlung: 1280-2560 (≈ 2-4% von 65535)
      - 2× so viel Traffic → Delta-Encoding NOCH wichtiger
    - **Implementierung:**
      - `_convert_to_artnet_data()` erweitern mit bit_depth Parameter
      - 16-bit: High-Byte = value >> 8, Low-Byte = value & 0xFF
      - Universe-Berechnung anpassen (6 statt 3 channels per LED)
  - **Phase 1: Basic Delta-Encoding**
    - Threshold-basierte Differenz-Erkennung (konfigurierbar 0-20 für 8-bit)
    - NumPy-optimierte Differenz-Berechnung (funktioniert für beide Modi)
    - Sende nur geänderte Pixel pro Universum
    - Config: `artnet.delta_encoding.enabled`, `threshold`, `threshold_16bit`
    - Automatische Threshold-Skalierung je nach bit_depth
  - **Phase 2: Full-Frame Sync**
    - Alle N Frames komplettes Update (Fehlerkorrektur bei Packet-Loss)
    - Config: `artnet.delta_encoding.full_frame_interval` (default: 30)
  - **Phase 3: Adaptive Threshold** (Optional)
    - Automatische Anpassung an Szenen-Komplexität
    - Schnelle Bewegung → höherer Threshold
    - Statische Szene → präziserer Threshold
  - **Phase 4: Spatial Grouping** (Optional)
    - Gruppiere benachbarte LEDs für effizientere Updates
  - **Geschätzter Gewinn:**
    - 50-90% weniger Netzwerk-Traffic (beide Modi)
    - 40-60% weniger CPU-Last beim Senden
    - 60+ FPS möglich (statt 30-40 FPS)
    - Cache wird überflüssig für Art-Net-Output
    - Bei 16-bit: Traffic-Reduktion kompensiert doppelte Datenmenge
  - **Trade-offs:**
    - +2-5ms CPU für Delta-Berechnung
    - +2-6KB Memory für last_sent_frame Buffer (bit_depth abhängig)
    - Funktioniert schlechter bei High-Motion-Szenen (100% Updates)

### Performance-Optimierung
- [ ] **Backend Performance-Optimierungen (Analyse 2025-11-22)**
  - [ ] **KRITISCH:** NumPy-Vektorisierung Stream-Loops (api_routes.py:334, 420)
    - Ersetze Python for-Loop durch NumPy fancy indexing
    - Geschätzter Gewinn: 40-60% CPU-Reduktion, -15ms Latenz
    - Impact: 10-50x Speedup bei 300+ LED-Punkten
  - [ ] **HOCH:** Entferne redundante Frame-Copies (api_routes.py:316, 402)
    - Direkter Zugriff statt `.copy()` mit Read-Lock
    - Geschätzter Gewinn: 15-20% CPU-Reduktion, spart 20 MB/s Memory-Bandwidth
  - [ ] **HOCH:** Async JPEG-Encoding (api_routes.py Stream-Generator)
    - Thread-Pool für cv2.imencode() oder Frame-Skip (30→15 FPS)
    - Geschätzter Gewinn: 25-35% CPU-Reduktion, -8ms Latenz
  - [ ] **MITTEL:** NumPy Channel-Reordering (artnet_manager.py:360-378)
    - Ersetze RGB→GRB Loop durch NumPy fancy indexing
    - Geschätzter Gewinn: 5-10% CPU-Reduktion, -2ms Latenz
  - [ ] **MITTEL:** Cache Gradient-Pattern (dmx_controller.py:257-276)
    - Vektorisierte HSV→RGB + Caching statt Neuberechnung
    - Geschätzter Gewinn: 1-3ms pro Pattern-Generation
  - [ ] **NIEDRIG:** Memory Leak Prevention (player.py:359)
    - Recording mit deque(maxlen=...) statt unbegrenzter Liste
    - Verhindert 195 MB nach 1h Recording
  - [ ] **NIEDRIG:** Event-basierte Synchronisation statt time.sleep()
    - threading.Event() für Pause-Handling
    - Reduziert Latenz-Spikes
  - [ ] **NIEDRIG:** Lock-free Stats (artnet_manager.py)
    - threading.local() statt Lock bei jedem Frame
    - Geschätzter Gewinn: 2-5% CPU-Reduktion
  - **Gesamtpotenzial: ~70% CPU-Reduktion, ~30ms weniger Latenz, bis zu 60 FPS**
- [ ] Video-Optimierungs-Script erstellen
  - [ ] Automatische Skalierung auf Canvas-Größe
  - [ ] Hardware-Codec Encoding (H.264 mit NVENC/QSV)
  - [ ] Bitrate-Optimierung für schnelleres Decoding
  - [ ] Keyframe-Intervall anpassen (g=30 für bessere Loop-Performance)
  - [ ] Batch-Processing für alle Videos in Kanal-Ordnern

### Neue Frame Sources
- [ ] ShaderToy Source (Echtzeit-3D-Shader)
  - [ ] ModernGL/PyOpenGL Integration
  - [ ] GLSL Shader Support (Shadertoy-kompatibel)
  - [ ] Uniform Variables (iTime, iResolution, iMouse)
  - [ ] Shader-Dateien aus shaders/ Ordner laden
  - [ ] Shadertoy-URL Import (API oder Scraping)
  - [ ] Performance-Profiling und GPU-Monitoring
- [ ] ImageSequence Source
  - [ ] PNG/JPG Sequenz-Support
  - [ ] Automatische Frame-Nummerierung
  - [ ] Variable Frame-Delays
- [ ] LiveStream Source
  - [ ] RTSP/HTTP Stream Support
  - [ ] FFmpeg/GStreamer Integration
  - [ ] Stream-Buffering und Reconnect

### Weitere Verbesserungen
- [ ] Unit Tests erweitern (Player, FrameSource, API)
- [ ] API-Authentifizierung (Basic Auth/Token)
- [ ] PyInstaller EXE Build Setup
  - [ ] Spec-Datei erstellen mit allen Dependencies
  - [ ] Single-File oder Folder-basierte Distribution testen
- ✓ Web-Interface Verbesserungen
    - ✓ Console Component in separates JS-Modul ausgelagert
    - ✓ Responsive Design für Mobile optimiert
    - ✓ LocalStorage für Settings Persistence (Brightness, Speed)
    - ✓ Canvas-Zoom & Scrollbars (Zoom per Maus & Buttons, automatische Scrollbalken)
    - ✓ Toast-Benachrichtigungen (statt alert, Theme-aware)
    - ✓ Server-Projektverwaltung (CRUD, Download, Modal-UI)
- [ ] Konfiguration erweitern
  - [ ] Environment Variable Support (target_ip, ports)
  - [ ] JSON Schema Validation für config.json
  - [ ] Hot-Reload (config.json watcher)
- [ ] Projekt-Struktur
  - [ ] Dockerfile erstellen

## Abgeschlossen ✓

### v2.0 - Unified Player Architecture (2025-11-20)
- ✓ Frame Source Abstraction (FrameSource base class)
- ✓ VideoSource Implementation (OpenCV-basiert, GIF-Support)
- ✓ ScriptSource Implementation (ScriptGenerator-Integration)
- ✓ Unified Player mit source switching
- ✓ Alle API-Routen aktualisiert (video/script loading)
- ✓ CLI Handler Migration (video/script/points)
- ✓ DMX Controller Integration
- ✓ Backward Compatibility (alte VideoPlayer/ScriptPlayer als deprecated)
- ✓ Stop/Start/Restart Playback-Fixes
- ✓ 90% Code-Duplikation eliminiert (~1300 → 850 Zeilen + neue Architektur)

### v1.x - Initial Implementation
- ✓ CLI-Steuerung implementiert
- ✓ DMX-Input über Art-Net (Universum 100)
- ✓ DMX-Test-App erstellt
- ✓ Video-Player mit Art-Net Output
- ✓ Numpy-Optimierung für RGB-Extraktion
- ✓ 8-Universen-Grenze Logik
- ✓ Brightness/Speed/Loop Steuerung
- ✓ Pause/Resume Funktionalität
- ✓ Blackout Funktion
- ✓ Code-Refactoring (Module-Struktur)
- ✓ Konfigurationsdatei (config.json)
- ✓ Video-Slot System (4 Kanäle, 1020 Videos, DMX Ch6-9)
- ✓ Hardware-Beschleunigung aktiviert mit Status-Ausgabe
- ✓ Kanal-Ordner System (kanal_1 bis kanal_4)
- ✓ Testmuster (Farben)
- ✓ RGB-Aufzeichnung
- ✓ Live-Statistiken
- ✓ Canvas-Größe Skalierung
- ✓ Multi-JSON Punkte-Verwaltung (list/validate/switch/reload)
- ✓ JSON Schema Validierung mit jsonschema
- ✓ Flask REST API komplett implementiert
  - ✓ Alle Playback Endpoints (play/stop/pause/resume/restart)
  - ✓ Settings Endpoints (brightness/speed/fps/loop)
  - ✓ Art-Net Endpoints (blackout/test)
  - ✓ Video Management (list/load)
  - ✓ Points Management (list/switch/reload/validate/current)
  - ✓ Status & Info & Stats Endpoints
  - ✓ Recording Endpoints (start/stop)
  - ✓ Console Endpoints (log/command/clear)
  - ✓ CORS Support aktiviert
- ✓ Web-Interfaces implementiert
  - ✓ Bootstrap GUI (index.html) - Canvas Editor
  - ✓ Control Panel (controls.html) - Playback Steuerung
  - ✓ Dark Mode mit LocalStorage
  - ✓ Externe CSS-Datei (styles.css)
  - ✓ Externe JS-Dateien (editor.js, controls.js)
  - ✓ Navigation zwischen GUIs
- ✓ WebSocket Support für Live-Updates
  - ✓ Flask-SocketIO Integration
  - ✓ Status Broadcasting (alle 2s)
  - ✓ Console Live-Updates
  - ✓ Fallback auf REST Polling
  - ✓ Werkzeug "write() before start_response" Bug gefixt (manage_session=False + disconnect error handling)
- ✓ Points Switch/Reload via REST API
  - ✓ /api/points/switch mit Validierung
  - ✓ /api/points/reload für aktuelles File
  - ✓ Auto-restart bei laufendem Video
- ✓ Bessere Error Handling & Validierung
  - ✓ Try/Except in allen API Endpoints
  - ✓ HTTP Status Codes (200, 400, 404, 500)
  - ✓ JSON Schema Validierung vor Points-Switch
- ✓ API Modularisierung
  - ✓ api_routes.py (Playback, Settings, Art-Net)
  - ✓ api_points.py (Points Management)
  - ✓ api_videos.py (Video Management)
  - ✓ api_console.py (Console & Commands)
- ✓ Dokumentation
  - ✓ docs/API.md (500+ Zeilen, alle Endpoints)
  - ✓ WebSocket Events dokumentiert
- ✓ Testing
  - ✓ tests/test_main.py (4 Test-Klassen)
  - ✓ Validator, ArtNetManager, Cache, Error Tests
- ✓ RGB Cache Infrastruktur
  - ✓ cache/ Ordner erstellt
  - ✓ cache clear/info CLI Befehle
  - ✓ config.json Einträge
  - ✓ .gitignore Patterns
- ✓ Art-Net Code Separation
  - ✓ artnet_manager.py Modul
  - ✓ Test-Pattern mit Gradient
  - ✓ Automatischer Art-Net Start
- ✓ Konfigurationswerte ausgelagert
  - ✓ API Host/Port/Secret Key in config.json
  - ✓ Art-Net FPS/Even Packet/Broadcast
  - ✓ Video Delays (shutdown/frame_wait/recording_stop)
  - ✓ Console Log Buffer Size
  - ✓ Status Broadcast Interval
  - ✓ Frontend Polling Interval
  - ✓ Frontend-Config API Endpoint (/api/config/frontend)
- ✓ RGB-Kanal-Reihenfolge pro Universum (Channel Mapping)
  - ✓ Unterstützt alle 6 Permutationen (RGB, GRB, BGR, RBG, GBR, BRG)
  - ✓ universe_configs in config.json
  - ✓ _reorder_channels() Methode in ArtNetManager
  - ✓ CLI-Befehle: artnet map/show mit Range-Syntax
  - ✓ Testmuster berücksichtigen Channel Mapping
  - ✓ Dokumentation in README und API.md
- ✓ Prozedural generierte Grafiken (Script Generator)
  - ✓ ScriptGenerator Klasse (list/load/generate)
  - ✓ ScriptPlayer Klasse (kompatibel mit VideoPlayer API)
  - ✓ Python Script API: generate_frame(frame_number, width, height, time, fps)
  - ✓ 10 Beispiel-Shaders (rainbow_wave, plasma, pulse, matrix_rain, fire, heartbeat, falling_blocks, line_*)
  - ✓ METADATA-System für Script-Infos
  - ✓ CLI-Befehle: scripts list, script:<name>
  - ✓ REST API Endpoints: GET /api/scripts, POST /api/load_script
  - ✓ Vollständige Dokumentation (scripts/README.md)
  - ✓ Error Handling mit Traceback
  - ✓ Lazy Module Loading (__init__.py __getattr__)
  - ✓ Dokumentation in README und API.md
- ✓ Command Execution Unified (2025-11-22)
  - ✓ CommandExecutor Klasse für gemeinsame Command-Handler Logik
  - ✓ CLIHandler nutzt CommandExecutor.execute()
  - ✓ API Console nutzt gemeinsamen Command-Handler
  - ✓ Code-Deduplizierung zwischen CLI und Web Console
  - ✓ Einheitliche CommandResult-Struktur
- ✓ Projekt-Struktur (2025-11-22)
  - ✓ requirements-lock.txt erstellt (27 Packages mit exakten Versionen)
