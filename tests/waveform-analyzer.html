<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Waveform Analyzer</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: #2b2b2b;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #e0e0e0;
        }
        
        .analyzer-section {
            display: grid;
            grid-template-columns: 260px 1fr;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            border-bottom: 2px solid #3c3c3c;
            background: #1e1e1e;
            margin-bottom: 20px;
        }
        
        .preview-box {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        
        .preview-area {
            width: 100%;
            height: 140px;
            background: #000;
            border: 2px dashed #3c3c3c;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .preview-area:hover {
            border-color: #667eea;
            color: #999;
        }
        
        .preview-area.drag-over {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }
        
        .controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-row {
            display: contents;
        }
        
        .btn {
            width: 36px;
            height: 36px;
            padding: 0;
            border: 1px solid #3c3c3c;
            border-radius: 3px;
            background: #2b2b2b;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn:hover {
            background: #3c3c3c;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
        }
        
        .btn-danger {
            background: #e74c3c;
            border-color: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover:not(:disabled) {
            background: #c0392b;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-info {
            font-size: 11px;
            color: #a0a0a0;
            text-align: center;
            padding: 4px;
        }
        
        .playlist-waveform-area {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            overflow: hidden;
        }
        
        .waveform-container {
            background: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 12px;
            flex-shrink: 0;
        }
        
        #waveform {
            margin-bottom: 12px;
        }
        
        .waveform-help {
            font-size: 12px;
            color: #a0a0a0;
            margin-top: 8px;
        }
        
        .slots-container {
            background: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 12px;
            flex: 1;
            overflow: hidden;
        }
        
        .slots-toggle {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 8px;
        }
        
        .minify-btn {
            padding: 4px 12px;
            background: #2b2b2b;
            border: 1px solid #3c3c3c;
            border-radius: 3px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .minify-btn:hover {
            background: #3c3c3c;
            border-color: #667eea;
        }
        
        .minify-btn.active {
            background: #667eea;
            border-color: #667eea;
            color: #fff;
        }
        
        .slots-container.minified .slot-time,
        .slots-container.minified .slot-split-editor {
            display: none;
        }
        
        .slots-container.minified .slot-item {
            padding: 8px 12px;
        }
        
        .waveform-container.minified .waveform-help,
        .waveform-container.minified .playback-info {
            display: none;
        }
        
        .waveform-container.minified {
            padding: 8px 12px;
        }
        
        .slots-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .slots-header h2 {
            font-size: 16px;
            color: #e0e0e0;
        }
        
        #slotsList {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 8px;
        }
        
        #slotsList::-webkit-scrollbar {
            height: 8px;
        }
        
        #slotsList::-webkit-scrollbar-track {
            background: #2b2b2b;
            border-radius: 4px;
        }
        
        #slotsList::-webkit-scrollbar-thumb {
            background: #3c3c3c;
            border-radius: 4px;
        }
        
        .slot-item {
            background: #2b2b2b;
            border: 2px solid #3c3c3c;
            border-radius: 4px;
            padding: 12px;
            min-width: 200px;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        
        .slot-item.active {
            border-color: #667eea;
            background: #3c3c3c;
        }
        
        .slot-header {
            margin-bottom: 8px;
        }
        
        .slot-title {
            font-size: 14px;
            font-weight: 500;
            color: #e0e0e0;
            margin-bottom: 4px;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        
        .slot-item.looping {
            border-color: #e74c3c;
            background: #3c3c3c;
            box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.3);
        }
        
        .slot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .slot-title {
            font-size: 14px;
            font-weight: 500;
            color: #e0e0e0;
        }
        
        .slot-item.active .slot-title {
            color: #667eea;
        }
        
        .slot-time {
            font-size: 12px;
            color: #a0a0a0;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        .countdown-circle {
            width: 20px;
            height: 20px;
            margin-left: 8px;
        }
        
        .countdown-circle circle {
            transform: rotate(-90deg);
            transform-origin: center;
            transition: stroke-dashoffset 0.1s linear;
        }
        
        .slot-split-editor {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            padding: 8px;
            background: #1e1e1e;
            border-radius: 3px;
        }
        
        .split-label {
            font-size: 11px;
            color: #a0a0a0;
        }
        
        .split-time-input {
            width: 80px;
            padding: 3px 6px;
            background: #0d0d0d;
            border: 1px solid #3c3c3c;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 11px;
            text-align: center;
            font-family: 'Consolas', monospace;
        }
        
        .split-time-input:focus {
            border-color: #667eea;
            outline: none;
        }
        
        .nudge-btn {
            padding: 3px 8px;
            background: #2b2b2b;
            border: 1px solid #3c3c3c;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .nudge-btn:hover {
            background: #3c3c3c;
            border-color: #667eea;
        }
        
        .nudge-btn:active {
            background: #667eea;
        }
        
        .slot-clip {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .slot-clip input {
            flex: 1;
            padding: 6px 10px;
            background: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 12px;
        }
        
        .slot-clip input::placeholder {
            color: #666;
        }
        
        .playback-info {
            display: flex;
            gap: 20px;
            font-size: 13px;
            color: #a0a0a0;
        }
        
        .playback-info span {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .playback-info strong {
            color: #e0e0e0;
        }
        
        .info-badge {
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .section-collapsible {
            position: relative;
        }
        
        .collapse-bar {
            height: 5px;
            background: #3c3c3c;
            position: relative;
            cursor: pointer;
            display: none;
        }
        
        .collapse-bar:hover {
            background: #4a4a4a;
        }
        
        .collapse-tab {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2b2b2b;
            border: 1px solid #3c3c3c;
            border-radius: 3px;
            padding: 2px 8px;
            font-size: 10px;
            color: #a0a0a0;
            pointer-events: none;
        }
        
        .section-collapsible.collapsed .collapse-bar {
            display: block;
            margin-bottom: 20px;
        }
        
        .section-collapsible.collapsed .waveform-container,
        .section-collapsible.collapsed .slots-container {
            display: none;
        }
        
        .section-collapsible:not(.collapsed) .waveform-container,
        .section-collapsible:not(.collapsed) .slots-container {
            position: relative;
        }
        
        .section-collapsible:not(.collapsed) .waveform-container::before,
        .section-collapsible:not(.collapsed) .slots-container::before {
            content: '‚è´';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            background: #2b2b2b;
            border: 1px solid #3c3c3c;
            border-radius: 3px;
            padding: 2px 8px;
            font-size: 10px;
            color: #a0a0a0;
            cursor: pointer;
            z-index: 10;
        }
        
        .section-collapsible:not(.collapsed) .waveform-container::before:hover,
        .section-collapsible:not(.collapsed) .slots-container::before:hover {
            background: #3c3c3c;
        }
    </style>
</head>
<body>
  
    
        
        <div class="analyzer-section">
            <!-- Preview Box -->
            <div class="preview-box">
                <div class="preview-area">
                    <span>üìä Drag & Drop MP3<br>or Click to Browse</span>
                </div>
                <div class="file-info" id="fileInfo">No file loaded</div>
                
                <!-- Controls -->
                <div class="controls">
                    <input type="file" id="audioFileInput" accept="audio/*">
                    <button class="btn" id="playBtn" disabled title="Play">‚ñ∂Ô∏è</button>
                    <button class="btn" id="pauseBtn" disabled title="Pause">‚è∏Ô∏è</button>
                    <button class="btn" id="stopBtn" disabled title="Stop">‚èπÔ∏è</button>
                    <button class="btn btn-danger" id="clearSplitsBtn" disabled title="Clear All Splits">üóëÔ∏è</button>
                    <button class="btn" id="minifyBtn" title="Minify">‚¨áÔ∏è</button>
                </div>
            </div>
            
            <!-- Waveform & Playlist Area -->
            <div class="playlist-waveform-area">
                <!-- Waveform -->
                <div class="waveform-container">
                        <div id="waveform"></div>
                        <div class="waveform-help">
                            üí° <strong>Click</strong> on waveform to add split | <strong>Right-click</strong> region to remove | <strong>Click slot</strong> to loop
                        </div>
                        <div class="playback-info" style="margin-top: 8px;">
                            <span><strong>Time:</strong> <span id="currentTime">0:00</span> / <span id="duration">0:00</span></span>
                            <span style="margin-left: 12px;"><strong>Slot:</strong> <span id="currentSlot" class="info-badge">None</span></span>
                        </div>
                </div>
                
                <!-- Slots Playlist -->
                <div class="slots-container" id="slotsContainer">
                    <div id="slotsList"></div>
                </div>
                </div>
            </div>
        </div>
    
    
    <!-- WaveSurfer.js v7 -->
    <script type="module">
        import WaveSurfer from 'https://cdn.jsdelivr.net/npm/wavesurfer.js@7/dist/wavesurfer.esm.js';
        import RegionsPlugin from 'https://cdn.jsdelivr.net/npm/wavesurfer.js@7/dist/plugins/regions.esm.js';
        import TimelinePlugin from 'https://cdn.jsdelivr.net/npm/wavesurfer.js@7/dist/plugins/timeline.esm.js';
        
        let wavesurfer = null;
        let regions = null;
        let timeline = null;
        let splits = []; // Array of split times in seconds
        let slots = []; // Array of {start, end, clipName}
        let currentSlotIndex = -1;
        let loopingSlot = null; // {start, end} or null if not looping
        
        // Initialize WaveSurfer
        function initWaveSurfer() {
            if (wavesurfer) {
                wavesurfer.destroy();
            }
            
            wavesurfer = WaveSurfer.create({
                container: '#waveform',
                waveColor: '#667eea',
                progressColor: '#5568d3',
                cursorColor: '#e74c3c',
                barWidth: 2,
                barGap: 1,
                height: 100,
                normalize: true,
                backend: 'WebAudio'
            });
            
            // Add regions plugin
            regions = wavesurfer.registerPlugin(RegionsPlugin.create());
            
            // Add timeline plugin
            timeline = wavesurfer.registerPlugin(TimelinePlugin.create({
                height: 20,
                timeInterval: 1,
                primaryLabelInterval: 5,
                style: {
                    fontSize: '11px',
                    color: '#a0a0a0'
                }
            }));
            
            // Event listeners
            wavesurfer.on('ready', onWaveformReady);
            wavesurfer.on('audioprocess', updatePlaybackInfo);
            wavesurfer.on('click', onWaveformClick);
            
            // Region events
            regions.on('region-created', onRegionCreated);
            regions.on('region-clicked', (region, e) => {
                if (e.button === 2) { // Right click
                    e.preventDefault();
                    e.stopPropagation();
                    removeRegion(region);
                    return false;
                }
            });
            regions.on('region-updated', onRegionResized);
            
            // Disable drag selection to avoid conflicts
            regions.enableDragSelection({
                color: 'rgba(102, 126, 234, 0.1)'
            });
        }
        
        function onWaveformReady() {
            document.getElementById('playBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('clearSplitsBtn').disabled = false;
            
            const duration = wavesurfer.getDuration();
            document.getElementById('duration').textContent = formatTime(duration);
            
            updateSlots();
        }
        
        function onWaveformClick(relativeX) {
            const duration = wavesurfer.getDuration();
            const time = relativeX * duration;
            addSplit(time);
        }
        
        function onRegionCreated(region) {
            // Add contextmenu handler to catch right-click
            const regionEl = region.element;
            if (regionEl) {
                regionEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    removeRegion(region);
                    return false;
                });
            }
        }
        
        function onRegionResized(region) {
            handleRegionResize(region);
        }
        
        function handleRegionResize(region) {
            const duration = wavesurfer.getDuration();
            const newStart = Math.round(region.start * 100) / 100;
            const newEnd = Math.round(region.end * 100) / 100;
            const slotIndex = region.slotIndex;
            
            // Get all current points
            const allPoints = [0, ...splits, duration];
            
            // Check if this is a left resize (start changed) or right resize (end changed)
            const originalStart = allPoints[slotIndex];
            const originalEnd = allPoints[slotIndex + 1];
            
            const leftResized = Math.abs(newStart - originalStart) > 0.01;
            const rightResized = Math.abs(newEnd - originalEnd) > 0.01;
            
            if (leftResized && slotIndex > 0) {
                // Left side resize - adjust split to the left
                const leftSplitIndex = slotIndex - 1;
                
                // Check if we're shrinking (moving right) or expanding (moving left)
                if (newStart < originalStart) {
                    // Expanding left - check if we overlap previous slot completely
                    const prevSlotStart = allPoints[slotIndex - 1];
                    
                    if (newStart <= prevSlotStart + 0.1) {
                        // Remove the previous split completely
                        splits.splice(leftSplitIndex, 1);
                    } else {
                        // Just adjust the split
                        splits[leftSplitIndex] = newStart;
                    }
                } else {
                    // Shrinking - moving split right
                    splits[leftSplitIndex] = newStart;
                }
            }
            
            if (rightResized && slotIndex < allPoints.length - 2) {
                // Right side resize - adjust split to the right
                const rightSplitIndex = slotIndex;
                
                // Check if we're shrinking (moving left) or expanding (moving right)
                if (newEnd > originalEnd) {
                    // Expanding right - check if we overlap next slot completely
                    const nextSlotEnd = allPoints[slotIndex + 2];
                    
                    if (newEnd >= nextSlotEnd - 0.1) {
                        // Remove the next split completely
                        splits.splice(rightSplitIndex, 1);
                    } else {
                        // Just adjust the split
                        splits[rightSplitIndex] = newEnd;
                    }
                } else {
                    // Shrinking - moving split left
                    splits[rightSplitIndex] = newEnd;
                }
            }
            
            // Ensure splits are sorted
            splits.sort((a, b) => a - b);
            
            // Update everything
            updateRegions();
            updateSlots();
        }
        
        function addSplit(time) {
            // Round to 2 decimals
            time = Math.round(time * 100) / 100;
            
            // Don't add if too close to start or end
            const duration = wavesurfer.getDuration();
            if (time < 0.1 || time > duration - 0.1) return;
            
            // Don't add if too close to existing split
            for (let split of splits) {
                if (Math.abs(split - time) < 0.5) return;
            }
            
            splits.push(time);
            splits.sort((a, b) => a - b);
            
            updateRegions();
            updateSlots();
        }
        
        function removeRegion(region) {
            // Find the split at the end of this region (right edge)
            // Or use the slotIndex to determine which split to remove
            const slotIndex = region.slotIndex;
            
            if (slotIndex === undefined || slotIndex < 0) return;
            
            // If this is not the last slot, remove the split at the end of this region
            const duration = wavesurfer.getDuration();
            const allPoints = [0, ...splits, duration];
            
            if (slotIndex < allPoints.length - 2) {
                // Remove the split at the right edge of this region
                splits.splice(slotIndex, 1);
            } else if (slotIndex > 0) {
                // If it's the last slot, remove the split at the left edge
                splits.splice(slotIndex - 1, 1);
            }
            
            updateRegions();
            updateSlots();
        }
        
        function updateRegions() {
            // Clear all regions
            regions.clearRegions();
            
            if (splits.length === 0) return;
            
            const duration = wavesurfer.getDuration();
            const allPoints = [0, ...splits, duration];
            
            // Create regions for each slot
            const colors = [
                'rgba(102, 126, 234, 0.2)',
                'rgba(76, 209, 196, 0.2)',
                'rgba(255, 107, 107, 0.2)',
                'rgba(255, 211, 61, 0.2)',
                'rgba(118, 75, 162, 0.2)',
                'rgba(69, 183, 209, 0.2)'
            ];
            
            for (let i = 0; i < allPoints.length - 1; i++) {
                const region = regions.addRegion({
                    start: allPoints[i],
                    end: allPoints[i + 1],
                    color: colors[i % colors.length],
                    drag: false,
                    resize: true,
                    minLength: 0.1,
                    maxLength: duration
                });
                
                // Store slot index on region
                region.slotIndex = i;
            }
        }
        
        function updateSplitTime(splitIndex, newTime) {
            if (splitIndex < 0 || splitIndex >= splits.length) return;
            
            const duration = wavesurfer.getDuration();
            
            // Get adjacent split times for validation
            const prevTime = splitIndex > 0 ? splits[splitIndex - 1] : 0;
            const nextTime = splitIndex < splits.length - 1 ? splits[splitIndex + 1] : duration;
            
            // Ensure split stays between adjacent splits with 0.1s minimum spacing
            newTime = Math.max(prevTime + 0.1, Math.min(nextTime - 0.1, newTime));
            newTime = Math.round(newTime * 100) / 100;
            
            splits[splitIndex] = newTime;
            splits.sort((a, b) => a - b);
            
            updateRegions();
            updateSlots();
        }
        
        function nudgeSplit(splitIndex, amount) {
            if (splitIndex < 0 || splitIndex >= splits.length) return;
            
            const newTime = splits[splitIndex] + amount;
            updateSplitTime(splitIndex, newTime);
        }
        
        function updateSlots() {
            if (!wavesurfer) return;
            
            const duration = wavesurfer.getDuration();
            const allPoints = [0, ...splits, duration];
            
            slots = [];
            for (let i = 0; i < allPoints.length - 1; i++) {
                const existingSlot = slots[i];
                slots.push({
                    index: i,
                    start: allPoints[i],
                    end: allPoints[i + 1],
                    clipName: existingSlot?.clipName || `Clip ${i}`
                });
            }
            
            renderSlots();
        }
        
        function renderSlots() {
            const container = document.getElementById('slotsList');
            
            if (slots.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 13px;">No slots. Click on waveform to create splits.</div>';
                return;
            }
            
            container.innerHTML = '';
            
            slots.forEach((slot, index) => {
                const div = document.createElement('div');
                div.className = 'slot-item';
                if (index === currentSlotIndex) {
                    div.classList.add('active');
                }
                if (loopingSlot && loopingSlot.index === index) {
                    div.classList.add('looping');
                }
                
                // Add click handler to play/loop this slot
                div.style.cursor = 'pointer';
                div.addEventListener('click', (e) => {
                    // Don't trigger if clicking on inputs or buttons
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') {
                        return;
                    }
                    
                    if (loopingSlot && loopingSlot.index === index) {
                        // Stop looping if clicking the same slot
                        wavesurfer.pause();
                        stopSlotLoop();
                    } else {
                        // Start looping this slot
                        playSlotLoop(index);
                    }
                });
                
                // Build split editor HTML if there's a split after this slot
                let splitEditorHTML = '';
                if (index < slots.length - 1) {
                    const splitTime = slot.end;
                    splitEditorHTML = `
                        <div class="slot-split-editor">
                            <span class="split-label">Split at:</span>
                            <input type="number" 
                                   class="split-time-input" 
                                   value="${splitTime.toFixed(2)}" 
                                   step="0.01" 
                                   data-split-index="${index}">
                            <span class="split-label">seconds</span>
                        </div>
                    `;
                }
                
                div.innerHTML = `
                    <div class="slot-header">
                        <div class="slot-title">
                            Slot ${slot.index}
                            <svg class="countdown-circle" data-slot-index="${index}" style="display: none;">
                                <circle cx="10" cy="10" r="8" fill="none" stroke="#3c3c3c" stroke-width="2"/>
                                <circle cx="10" cy="10" r="8" fill="none" stroke="#667eea" stroke-width="2" 
                                        class="countdown-progress" 
                                        stroke-dasharray="50.265" 
                                        stroke-dashoffset="0"/>
                            </svg>
                            <div class="slot-time">${formatTime(slot.start)} - ${formatTime(slot.end)} (${formatTime(slot.end - slot.start)})</div>
                        </div>
                    </div>
                    ${splitEditorHTML}
                `;
                
                // Add split time editor listeners
                const splitInput = div.querySelector('.split-time-input');
                if (splitInput) {
                    splitInput.addEventListener('change', (e) => {
                        const newTime = parseFloat(e.target.value);
                        updateSplitTime(index, newTime);
                    });
                }
                
                container.appendChild(div);
            });
        }
        
        function updatePlaybackInfo() {
            const currentTime = wavesurfer.getCurrentTime();
            document.getElementById('currentTime').textContent = formatTime(currentTime);
            
            // Handle slot looping
            if (loopingSlot && currentTime >= loopingSlot.end) {
                wavesurfer.seekTo(loopingSlot.start / wavesurfer.getDuration());
            }
            
            // Find current slot
            let newSlotIndex = -1;
            for (let i = 0; i < slots.length; i++) {
                if (currentTime >= slots[i].start && currentTime < slots[i].end) {
                    newSlotIndex = i;
                    break;
                }
            }
            
            // Update countdown circles
            document.querySelectorAll('.countdown-circle').forEach(circle => {
                const slotIndex = parseInt(circle.dataset.slotIndex);
                const slot = slots[slotIndex];
                
                if (slotIndex === newSlotIndex && currentTime >= slot.start && currentTime < slot.end) {
                    // Show and update countdown for current slot
                    circle.style.display = 'inline-block';
                    const slotDuration = slot.end - slot.start;
                    const elapsed = currentTime - slot.start;
                    const progress = elapsed / slotDuration;
                    const circumference = 50.265; // 2 * PI * 8
                    const offset = circumference * (1 - progress);
                    
                    const progressCircle = circle.querySelector('.countdown-progress');
                    progressCircle.style.strokeDashoffset = offset;
                } else {
                    circle.style.display = 'none';
                }
            });
            
            if (newSlotIndex !== currentSlotIndex) {
                currentSlotIndex = newSlotIndex;
                document.getElementById('currentSlot').textContent = 
                    currentSlotIndex >= 0 ? `Slot ${currentSlotIndex}` : 'None';
                renderSlots();
            }
        }
        
        function playSlotLoop(slotIndex) {
            if (slotIndex < 0 || slotIndex >= slots.length) return;
            
            const slot = slots[slotIndex];
            loopingSlot = { start: slot.start, end: slot.end, index: slotIndex };
            
            // Seek to start of slot and play
            wavesurfer.seekTo(slot.start / wavesurfer.getDuration());
            wavesurfer.play();
            
            renderSlots();
        }
        
        function stopSlotLoop() {
            loopingSlot = null;
            renderSlots();
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Load audio file helper
        function loadAudioFile(file) {
            if (!file) return;
            
            // Check if it's an audio file
            if (!file.type.startsWith('audio/')) {
                alert('Please select an audio file (MP3, WAV, etc.)');
                return;
            }
            
            document.getElementById('fileInfo').textContent = file.name;
            
            initWaveSurfer();
            
            const url = URL.createObjectURL(file);
            wavesurfer.load(url);
        }
        
        // Button handlers
        document.getElementById('audioFileInput').addEventListener('change', (e) => {
            loadAudioFile(e.target.files[0]);
        });
        
        // Drag and drop handlers
        const previewArea = document.querySelector('.preview-area');
        
        previewArea.addEventListener('click', () => {
            document.getElementById('audioFileInput').click();
        });
        
        previewArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            previewArea.classList.add('drag-over');
        });
        
        previewArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            previewArea.classList.remove('drag-over');
        });
        
        previewArea.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            previewArea.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                loadAudioFile(files[0]);
            }
        });
        
        document.getElementById('playBtn').addEventListener('click', () => {
            wavesurfer.play();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            wavesurfer.pause();
        });
        
        document.getElementById('stopBtn').addEventListener('click', () => {
            wavesurfer.stop();
            currentSlotIndex = -1;
            document.getElementById('currentSlot').textContent = 'None';
            document.getElementById('currentTime').textContent = '0:00';
            renderSlots();
        });
        
        document.getElementById('clearSplitsBtn').addEventListener('click', () => {
            if (confirm('Clear all splits?')) {
                splits = [];
                updateRegions();
                updateSlots();
            }
        });
        
        // Prevent context menu on waveform
        document.getElementById('waveform').addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Minify toggle
        const minifyBtn = document.getElementById('minifyBtn');
        const slotsContainer = document.getElementById('slotsContainer');
        const waveformContainer = document.querySelector('.waveform-container');
        minifyBtn.addEventListener('click', () => {
            slotsContainer.classList.toggle('minified');
            waveformContainer.classList.toggle('minified');
            const isMinified = slotsContainer.classList.contains('minified');
            minifyBtn.textContent = isMinified ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';
            minifyBtn.title = isMinified ? 'Expand' : 'Minify';
        });
    </script>
</body>
</html>
