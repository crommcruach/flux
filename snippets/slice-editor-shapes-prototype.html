<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slice Editor with Shapes & Masks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Left Panel */
        .left-panel {
            width: 320px;
            background: #151515;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: width 0.3s ease;
        }

        .left-panel.collapsed {
            width: 50px;
        }

        .left-panel.collapsed .panel-section-content,
        .left-panel.collapsed h2 span {
            display: none;
        }

        /* Center Panel */
        .canvas-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0a0a0a;
            padding: 20px;
        }

        .canvas-header {
            margin-bottom: 15px;
        }

        .canvas-header h1 {
            font-size: 24px;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .canvas-info {
            display: flex;
            gap: 20px;
            font-size: 12px;
            color: #888;
        }

        .canvas-wrapper {
            position: relative;
            flex: 1;
            background: #000;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #canvasContainer {
            position: relative;
            background: #222;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px 12px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .zoom-controls button {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #555;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
            min-width: 32px;
        }

        .zoom-controls button:hover {
            background: #3a3a3a;
            border-color: #4CAF50;
        }

        .zoom-level {
            color: #4CAF50;
            font-size: 14px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }

        #videoCanvas {
            display: block;
        }

        #sliceCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: default;
        }

        /* Right Panel */
        .right-panel {
            width: 350px;
            background: #151515;
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-section {
            padding: 20px;
            border-bottom: 1px solid #222;
        }

        .panel-section h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #4CAF50;
        }

        /* Shape Tools */
        .shape-tools {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 10px 0;
        }

        .shape-btn {
            padding: 12px 8px;
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 20px;
            text-align: center;
            transition: all 0.2s;
        }

        .shape-btn:hover {
            background: #333;
            border-color: #4CAF50;
        }

        .shape-btn.active {
            background: #2a4a2a;
            border-color: #4CAF50;
        }

        /* Type Toggle */
        .type-toggle {
            display: flex;
            gap: 8px;
            margin: 10px 0;
        }

        .panel-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
            z-index: 10;
        }

        .panel-toggle:hover {
            background: #333;
            border-color: #4CAF50;
        }

        .right-panel.collapsed {
            width: 50px;
        }

        .right-panel.collapsed .slices-list h2 span,
        .right-panel.collapsed .panel-section h2 span,
        .right-panel.collapsed .panel-section-content,
        .right-panel.collapsed #slicesList {
            display: none;
        }

        .type-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .type-btn.slice {
            background: #1a3a1a;
            color: #4CAF50;
        }

        .type-btn.slice.active {
            border-color: #4CAF50;
            font-weight: bold;
        }

        .type-btn.mask {
            background: #1a1a3a;
            color: #e91e63;
        }

        .type-btn.mask.active {
            border-color: #e91e63;
            font-weight: bold;
        }

        /* Buttons */
        button {
            padding: 10px 16px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        button:hover {
            background: #333;
            border-color: #4CAF50;
        }

        button.primary {
            background: #2a4a2a;
            border-color: #4CAF50;
        }

        button.danger {
            background: #4a2a2a;
            border-color: #f44336;
        }

        /* Inputs */
        .input-row {
            display: flex;
            gap: 10px;
        }

        .input-group {
            flex: 1;
        }

        label {
            display: block;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        /* Slices List */
        .slices-list {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .screen-group {
            margin-bottom: 20px;
        }

        .screen-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #2a2a2a;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .slice-item {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .slice-item:hover {
            background: #222;
            border-color: #4CAF50;
        }

        .slice-item.active {
            background: #2a4a2a;
            border-color: #4CAF50;
        }

        .slice-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .slice-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            display: inline-block;
            margin-right: 8px;
        }

        .slice-item-title {
            font-weight: 500;
        }

        .slice-item-info {
            font-size: 11px;
            color: #888;
            display: flex;
            justify-content: space-between;
        }

        .screen-checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .screen-checkbox-item:hover {
            background: #2a2a2a;
            border-color: #4CAF50;
        }

        .screen-checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #4CAF50;
        }

        .screen-checkbox-item label {
            flex: 1;
            cursor: pointer;
            user-select: none;
            margin: 0;
        }

        .screen-checkbox-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        /* Preview Modal */
        .preview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .preview-modal.active {
            display: flex;
        }

        .preview-content {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .preview-header h3 {
            margin: 0;
            color: #4CAF50;
            font-size: 18px;
        }

        .preview-close {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .preview-close:hover {
            background: #d32f2f;
        }

        .preview-canvas-wrapper {
            background: #000;
            border: 1px solid #555;
            border-radius: 4px;
            display: inline-block;
            padding: 10px;
        }

        #previewCanvas {
            display: block;
            border: 2px solid #4CAF50;
        }

        .preview-info {
            margin-top: 15px;
            padding: 10px;
            background: #0a0a0a;
            border-radius: 4px;
            font-size: 12px;
            color: #888;
        }

        .preview-info-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .preview-info-label {
            color: #4CAF50;
        }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast.error {
            background: #d32f2f;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel -->
        <div class="left-panel" id="leftPanel">
            <div class="panel-toggle" onclick="app.togglePanel('left')" title="Toggle Panel">‚óÄ</div>
            <div class="panel-section" id="canvasSection">
                <h2>‚öôÔ∏è Canvas</h2>
                <div class="panel-section-content">
                    <div class="input-row">
                        <div class="input-group">
                            <label>Width</label>
                            <input type="number" id="canvasWidth" value="1920" onchange="app.updateCanvasSize()">
                        </div>
                        <div class="input-group">
                            <label>Height</label>
                            <input type="number" id="canvasHeight" value="1080" onchange="app.updateCanvasSize()">
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel-section" id="toolsSection">
                <h2>üõ†Ô∏è Tools</h2>
                <div class="panel-section-content">
                <div class="type-toggle">
                    <div class="type-btn slice active" onclick="app.setType('slice')" id="typeSliceBtn">
                        ‚ñ≠ Slice
                    </div>
                    <div class="type-btn mask" onclick="app.setType('mask')" id="typeMaskBtn">
                        ‚óê Mask
                    </div>
                </div>
                <div id="maskWarning" style="display: none; font-size: 11px; color: #ff9800; padding: 8px; background: #3a2a1a; border-radius: 4px; margin: 10px 0;">
                    ‚ö†Ô∏è Select a slice first to add masks
                </div>

                <div id="shapeTypeSection" style="display: none;">
                    <div style="font-size: 11px; color: #999; margin: 10px 0;">Shape Type:</div>
                    <div class="shape-tools">
                        <button class="shape-btn active" onclick="app.setShape('rectangle')" id="shapeRectangleBtn" title="Rectangle">‚ñ≠</button>
                        <button class="shape-btn" onclick="app.setShape('circle')" id="shapeCircleBtn" title="Circle">‚óã</button>
                        <button class="shape-btn" onclick="app.setShape('triangle')" id="shapeTriangleBtn" title="Triangle">‚ñ≥</button>
                        <button class="shape-btn" onclick="app.setShape('polygon')" id="shapePolygonBtn" title="Polygon">‚¨°</button>
                        <button class="shape-btn" onclick="app.setShape('freehand')" id="shapeFreehandBtn" title="Freehand">‚úèÔ∏è</button>
                    </div>
                </div>

                <div style="display: flex; gap: 8px; flex-direction: column;">
                    <button class="primary" onclick="app.startDrawing()" id="addShapeBtn">‚ûï Add Rectangle</button>
                    <button onclick="app.finishDrawing()" id="finishDrawBtn" style="display: none; background: #4CAF50;">‚úì Finish</button>
                    <button onclick="app.cancelDrawing()" id="cancelDrawBtn" style="display: none;">‚úï Cancel</button>
                    <button onclick="app.deleteSelected()">üóëÔ∏è Delete</button>
                    <button onclick="app.showPreview()" id="previewBtn">üîç Preview Slice</button>
                    <button onclick="app.toggleSnap()" id="snapBtn">üìê Snap: OFF</button>
                    <button onclick="app.toggleTransformMode()" id="transformBtn">üîß Transform</button>
                </div>
                </div>
            </div>

            <div class="panel-section" id="outputsSection">
                <h2>üñ•Ô∏è Outputs</h2>
                <div class="panel-section-content">
                <div style="font-size: 11px; color: #999; margin-bottom: 10px;">Multi-select:</div>
                <div id="screenButtonsContainer" style="display: flex; gap: 6px; flex-direction: column;">
                    <!-- Checkboxes generated -->
                </div>
                <button class="primary" onclick="app.addOutput()" style="margin-top: 10px; width: 100%;">‚ûï Add Output</button>
                </div>
            </div>
        </div>

        <!-- Center Panel -->
        <div class="canvas-panel">
            <div class="canvas-header">
                <h1>üé¨ Slice Editor - Shapes & Masks</h1>
                <div class="canvas-info">
                    <span>Canvas: <strong id="canvasDimensions">1920x1080</strong></span>
                    <span>Mouse: <strong id="mousePosition">--, --</strong></span>
                    <span>Selected: <strong id="selectedSlice">None</strong></span>
                </div>
            </div>

            <div class="canvas-wrapper" id="canvasWrapper">
                <div id="canvasContainer">
                    <canvas id="videoCanvas"></canvas>
                    <canvas id="sliceCanvas"></canvas>
                </div>
                <div class="zoom-controls">
                    <button onclick="window.app.zoomOut()" title="Zoom Out">‚àí</button>
                    <div class="zoom-level" id="zoomLevel">100%</div>
                    <button onclick="window.app.zoomIn()" title="Zoom In">+</button>
                    <button onclick="window.app.resetZoom()" title="Reset Zoom" style="font-size: 12px;">1:1</button>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel" id="rightPanel">
            <div class="panel-toggle" onclick="app.togglePanel('right')" title="Toggle Panel" style="left: 10px; right: auto;">‚ñ∂</div>
            <div class="slices-list">
                <h2>üì¶ Shapes (<span id="sliceCount">0</span>)</h2>
                <div id="slicesList"></div>
            </div>

            <div class="panel-section" id="exportSection">
                <h2>üíæ Export / Import</h2>
                <div class="panel-section-content">
                    <div style="display: flex; gap: 8px; flex-direction: column;">
                        <button class="primary" onclick="app.exportJSON()">üì• Export JSON</button>
                        <button onclick="document.getElementById('importFile').click()">üì§ Import JSON</button>
                        <input type="file" id="importFile" accept=".json" onchange="app.importJSON(event)" style="display: none;">
                        <button onclick="app.clearAll()" class="danger">üóëÔ∏è Clear All</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Preview Modal -->
    <div id="previewModal" class="preview-modal">
        <div class="preview-content">
            <div class="preview-header">
                <h3>Slice Preview</h3>
                <button class="preview-close" onclick="app.closePreview()">‚úï Close</button>
            </div>
            <div class="preview-canvas-wrapper">
                <canvas id="previewCanvas"></canvas>
            </div>
            <div class="preview-info" id="previewInfo"></div>
        </div>
    </div>

    <script>
        const app = {
            canvas: null,
            ctx: null,
            videoCanvas: null,
            videoCtx: null,
            canvasWidth: 1920,
            canvasHeight: 1080,
            canvasZoom: 1.0,
            scale: 1,
            slices: [],
            selectedSlice: null,
            isDragging: false,
            isResizing: false,
            isRotating: false,
            isTransforming: false,
            transformMode: false,
            draggingCorner: null,
            dragStart: null,
            resizeHandle: null,
            snapToGrid: false,
            gridSize: 10,
            screens: ['HDMI1', 'HDMI2', 'HDMI3', 'Virtual'],
            customScreens: [],
            colors: ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#00BCD4', '#FFEB3B', '#E91E63', '#8BC34A'],
            colorIndex: 0,
            
            // Shape drawing
            currentShape: 'rectangle',
            currentType: 'slice',
            drawingMode: false,
            drawingPoints: [],
            tempShape: null,

            init() {
                this.canvas = document.getElementById('sliceCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.videoCanvas = document.getElementById('videoCanvas');
                this.videoCtx = this.videoCanvas.getContext('2d');

                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                
                // Mouse wheel zoom
                const wrapper = document.getElementById('canvasWrapper');
                wrapper.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -1 : 1;
                        if (delta > 0) {
                            this.zoomIn();
                        } else {
                            this.zoomOut();
                        }
                    }
                }, { passive: false });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Delete') this.deleteSelected();
                    if (e.key === 'Escape') this.cancelDrawing();
                    if (e.ctrlKey && e.key === 'd') {
                        e.preventDefault();
                        this.duplicateSelected();
                    }
                });

                this.updateCanvasSize();
                this.loadFromLocalStorage();
                this.updateScreenButtons();
                this.updateUI();
                this.render();
            },

            setType(type) {
                this.currentType = type;
                document.getElementById('typeSliceBtn').classList.toggle('active', type === 'slice');
                document.getElementById('typeMaskBtn').classList.toggle('active', type === 'mask');
                
                // Force rectangle for slices, show shape selector only for masks
                const shapeSection = document.getElementById('shapeTypeSection');
                if (type === 'slice') {
                    this.currentShape = 'rectangle';
                    shapeSection.style.display = 'none';
                } else {
                    shapeSection.style.display = 'block';
                }
                
                // Show warning if trying to add mask without selected slice
                const warning = document.getElementById('maskWarning');
                if (type === 'mask' && (!this.selectedSlice || this.selectedSlice.type === 'mask')) {
                    warning.style.display = 'block';
                } else {
                    warning.style.display = 'none';
                }
                
                this.updateAddButton();
            },

            setShape(shape) {
                this.currentShape = shape;
                ['Rectangle', 'Circle', 'Triangle', 'Polygon', 'Freehand'].forEach(s => {
                    const btn = document.getElementById(`shape${s}Btn`);
                    if (btn) btn.classList.toggle('active', s.toLowerCase() === shape);
                });
                this.updateAddButton();
            },

            updateAddButton() {
                const btn = document.getElementById('addShapeBtn');
                if (btn) {
                    if (this.currentType === 'slice') {
                        btn.textContent = `‚ûï Add Slice`;
                    } else {
                        const shape = this.currentShape || 'rectangle';
                        const shapeLabel = shape.charAt(0).toUpperCase() + shape.slice(1);
                        btn.textContent = `‚ûï Add Mask (${shapeLabel})`;
                    }
                }
            },

            startDrawing() {
                // Don't allow adding mask without a selected slice
                if (this.currentType === 'mask' && (!this.selectedSlice || this.selectedSlice.type === 'mask')) {
                    this.showToast('Select a slice first to add masks', 'error');
                    return;
                }
                
                this.drawingMode = true;
                this.drawingPoints = [];
                this.tempShape = null;
                const needsFinish = ['polygon', 'freehand'].includes(this.currentShape);
                document.getElementById('finishDrawBtn').style.display = needsFinish ? 'block' : 'none';
                document.getElementById('cancelDrawBtn').style.display = 'block';
                this.canvas.style.cursor = 'crosshair';
                this.showToast(`Draw ${this.currentShape}`);
            },

            finishDrawing() {
                if (this.drawingPoints.length < 3 && ['polygon', 'triangle'].includes(this.currentShape)) {
                    this.showToast('Need at least 3 points', 'error');
                    return;
                }
                this.createShapeFromDrawing();
                this.cancelDrawing();
            },

            cancelDrawing() {
                this.drawingMode = false;
                this.drawingPoints = [];
                this.tempShape = null;
                document.getElementById('finishDrawBtn').style.display = 'none';
                document.getElementById('cancelDrawBtn').style.display = 'none';
                this.canvas.style.cursor = 'default';
                this.render();
            },

            createShapeFromDrawing() {
                const id = 'shape_' + Date.now();
                const color = this.colors[this.colorIndex % this.colors.length];
                this.colorIndex++;
                
                let shape = {
                    id: id,
                    type: this.currentType,
                    shape: this.currentShape,
                    color: color,
                    label: `${this.currentType === 'mask' ? 'Mask' : 'Slice'} ${this.slices.filter(s => s.type === this.currentType).length + 1}`,
                    visible: true
                };

                // Only slices have screens and masks
                if (this.currentType === 'slice') {
                    shape.screens = ['HDMI1'];
                    shape.masks = [];
                    shape.brightness = 0;
                    shape.contrast = 0;
                    shape.red = 0;
                    shape.green = 0;
                    shape.blue = 0;
                    shape.softEdge = false;
                    shape.mirror = 'none'; // none, horizontal, vertical, both
                }

                if (this.currentShape === 'rectangle' && this.tempShape) {
                    let x = Math.min(this.tempShape.x, this.tempShape.x + this.tempShape.width);
                    let y = Math.min(this.tempShape.y, this.tempShape.y + this.tempShape.height);
                    let w = Math.abs(this.tempShape.width);
                    let h = Math.abs(this.tempShape.height);
                    if (w < 10 || h < 10) return;
                    shape.x = x;
                    shape.y = y;
                    shape.width = w;
                    shape.height = h;
                } else if (this.currentShape === 'circle' && this.tempShape) {
                    if (this.tempShape.radius < 5) return;
                    shape.centerX = this.tempShape.centerX;
                    shape.centerY = this.tempShape.centerY;
                    shape.radius = this.tempShape.radius;
                } else if (['triangle', 'polygon', 'freehand'].includes(this.currentShape)) {
                    if (this.drawingPoints.length < 2) return;
                    shape.points = [...this.drawingPoints];
                }

                if (this.currentType === 'slice') {
                    // Add as new slice
                    this.slices.push(shape);
                    this.selectedSlice = shape;
                } else {
                    // Add as mask to selected slice
                    if (this.selectedSlice && this.selectedSlice.type === 'slice') {
                        if (!this.selectedSlice.masks) this.selectedSlice.masks = [];
                        console.log('Adding mask to slice:', shape);
                        this.selectedSlice.masks.push(shape);
                        // Keep the parent slice selected
                    }
                }

                this.updateUI();
                this.render();
                this.saveToLocalStorage();
                this.showToast(`${shape.label} created`);
            },

            onMouseDown(e) {
                const pos = this.getMousePos(e);

                if (this.drawingMode) {
                    if (this.currentShape === 'rectangle') {
                        this.tempShape = { x: pos.x, y: pos.y, width: 0, height: 0 };
                        this.isDragging = true;
                    } else if (this.currentShape === 'circle') {
                        if (!this.tempShape) {
                            this.tempShape = { centerX: pos.x, centerY: pos.y, radius: 0 };
                            this.isDragging = true;
                        }
                    } else if (this.currentShape === 'triangle') {
                        this.drawingPoints.push({x: pos.x, y: pos.y});
                        if (this.drawingPoints.length === 3) {
                            this.createShapeFromDrawing();
                            this.cancelDrawing();
                        }
                        this.render();
                    } else if (this.currentShape === 'polygon') {
                        this.drawingPoints.push({x: pos.x, y: pos.y});
                        this.render();
                    } else if (this.currentShape === 'freehand') {
                        this.drawingPoints = [{x: pos.x, y: pos.y}];
                        this.isDragging = true;
                    }
                    return;
                }

                // Check if clicking on transform corner
                if (this.transformMode && this.selectedSlice && this.selectedSlice.shape === 'rectangle') {
                    const corner = this.getTransformCorner(pos, this.selectedSlice);
                    if (corner !== null) {
                        this.isTransforming = true;
                        this.draggingCorner = corner;
                        return;
                    }
                }

                // Check rotation handle (rectangles only)
                if (this.selectedSlice && this.selectedSlice.shape === 'rectangle' && this.isOnRotationHandle(pos, this.selectedSlice)) {
                    this.isRotating = true;
                    this.dragStart = pos;
                    return;
                }

                // Check resize handle (rectangles only)
                if (this.selectedSlice && this.selectedSlice.shape === 'rectangle') {
                    const handle = this.getResizeHandle(pos, this.selectedSlice);
                    if (handle) {
                        this.isResizing = true;
                        this.resizeHandle = handle;
                        this.dragStart = pos;
                        return;
                    }
                }

                // Check click on shape
                const clickedSlice = this.getSliceAt(pos);
                if (clickedSlice) {
                    this.selectedSlice = clickedSlice;
                    this.isDragging = true;
                    this.dragStart = pos;
                } else {
                    this.selectedSlice = null;
                }

                this.updateUI();
                this.render();
            },

            onMouseMove(e) {
                const pos = this.getMousePos(e);
                document.getElementById('mousePosition').textContent = `${Math.round(pos.x)}, ${Math.round(pos.y)}`;

                if (this.isTransforming && this.draggingCorner !== null && this.selectedSlice) {
                    this.moveTransformCorner(pos);
                    this.render();
                    return;
                }

                if (this.drawingMode && this.isDragging) {
                    if (this.currentShape === 'rectangle' && this.tempShape) {
                        this.tempShape.width = pos.x - this.tempShape.x;
                        this.tempShape.height = pos.y - this.tempShape.y;
                        this.render();
                    } else if (this.currentShape === 'circle' && this.tempShape) {
                        const dx = pos.x - this.tempShape.centerX;
                        const dy = pos.y - this.tempShape.centerY;
                        this.tempShape.radius = Math.sqrt(dx * dx + dy * dy);
                        this.render();
                    } else if (this.currentShape === 'freehand') {
                        this.drawingPoints.push({x: pos.x, y: pos.y});
                        this.render();
                    }
                    return;
                }

                if (this.isRotating && this.selectedSlice) {
                    this.rotateSlice(pos);
                    this.render();
                } else if (this.isDragging && this.selectedSlice) {
                    const dx = pos.x - this.dragStart.x;
                    const dy = pos.y - this.dragStart.y;
                    this.moveShape(this.selectedSlice, dx, dy);
                    this.dragStart = pos;
                    this.render();
                } else if (this.isResizing && this.selectedSlice) {
                    this.resizeSlice(pos);
                    this.render();
                }
            },

            onMouseUp(e) {
                if (this.drawingMode && this.isDragging) {
                    if (['rectangle', 'circle'].includes(this.currentShape)) {
                        this.createShapeFromDrawing();
                        this.cancelDrawing();
                    } else if (this.currentShape === 'freehand' && this.drawingPoints.length > 5) {
                        this.createShapeFromDrawing();
                        this.cancelDrawing();
                    }
                }

                this.isDragging = false;
                this.isResizing = false;
                this.isRotating = false;
                this.isTransforming = false;
                this.draggingCorner = null;
                this.resizeHandle = null;

                if (!this.drawingMode) {
                    this.saveToLocalStorage();
                }
                this.updateUI();
                this.render();
            },

            snapToGridPos(pos) {
                if (!this.snapToGrid) return pos;
                return {
                    x: Math.round(pos.x / this.gridSize) * this.gridSize,
                    y: Math.round(pos.y / this.gridSize) * this.gridSize
                };
            },

            moveShape(shape, dx, dy) {
                if (shape.shape === 'rectangle') {
                    let newX = shape.x + dx;
                    let newY = shape.y + dy;
                    
                    if (this.snapToGrid) {
                        const snapped = this.snapToGridPos({ x: newX, y: newY });
                        newX = snapped.x;
                        newY = snapped.y;
                    }
                    
                    // Check for center alignment and snap
                    const centerX = newX + shape.width / 2;
                    const centerY = newY + shape.height / 2;
                    const canvasCenterX = this.canvasWidth / 2;
                    const canvasCenterY = this.canvasHeight / 2;
                    const snapThreshold = 10;
                    
                    if (Math.abs(centerX - canvasCenterX) < snapThreshold) {
                        newX = canvasCenterX - shape.width / 2;
                    }
                    if (Math.abs(centerY - canvasCenterY) < snapThreshold) {
                        newY = canvasCenterY - shape.height / 2;
                    }
                    
                    // Bounds checking
                    newX = Math.max(0, Math.min(newX, this.canvasWidth - shape.width));
                    newY = Math.max(0, Math.min(newY, this.canvasHeight - shape.height));
                    
                    // Calculate actual movement after snapping and bounds
                    const actualDx = newX - shape.x;
                    const actualDy = newY - shape.y;
                    
                    shape.x = newX;
                    shape.y = newY;
                    
                    // Move masks with the slice if this is a slice with masks
                    if (shape.type === 'slice' && shape.masks && shape.masks.length > 0) {
                        shape.masks.forEach(mask => {
                            if (mask.shape === 'rectangle') {
                                mask.x += actualDx;
                                mask.y += actualDy;
                            } else if (mask.shape === 'circle') {
                                mask.centerX += actualDx;
                                mask.centerY += actualDy;
                            } else if (mask.points) {
                                mask.points.forEach(p => {
                                    p.x += actualDx;
                                    p.y += actualDy;
                                });
                            }
                        });
                    }
                } else if (shape.shape === 'circle') {
                    shape.centerX = Math.max(shape.radius, Math.min(shape.centerX + dx, this.canvasWidth - shape.radius));
                    shape.centerY = Math.max(shape.radius, Math.min(shape.centerY + dy, this.canvasHeight - shape.radius));
                } else if (shape.points) {
                    shape.points.forEach(p => {
                        p.x += dx;
                        p.y += dy;
                    });
                }
            },

            isOnRotationHandle(pos, slice) {
                if (slice.shape !== 'rectangle') return false;
                const centerX = slice.x + slice.width / 2;
                const rotHandleY = slice.y - 30;
                const distance = Math.sqrt(Math.pow(pos.x - centerX, 2) + Math.pow(pos.y - rotHandleY, 2));
                return distance <= 15;
            },

            getTransformCorner(pos, slice) {
                if (!slice.transformCorners) {
                    // Initialize transform corners as regular rectangle corners
                    slice.transformCorners = [
                        {x: 0, y: 0}, // top-left
                        {x: slice.width, y: 0}, // top-right
                        {x: slice.width, y: slice.height}, // bottom-right
                        {x: 0, y: slice.height} // bottom-left
                    ];
                }

                const handleSize = 12;
                for (let i = 0; i < slice.transformCorners.length; i++) {
                    const corner = slice.transformCorners[i];
                    const cornerX = slice.x + corner.x;
                    const cornerY = slice.y + corner.y;
                    
                    if (Math.abs(pos.x - cornerX) < handleSize && Math.abs(pos.y - cornerY) < handleSize) {
                        return i;
                    }
                }
                return null;
            },

            moveTransformCorner(pos) {
                const slice = this.selectedSlice;
                if (!slice || !slice.transformCorners) return;

                // Update corner position relative to slice origin
                const corner = slice.transformCorners[this.draggingCorner];
                corner.x = Math.max(0, Math.min(slice.width, pos.x - slice.x));
                corner.y = Math.max(0, Math.min(slice.height, pos.y - slice.y));
            },

            drawTransformHandles(slice) {
                if (!slice.transformCorners) {
                    slice.transformCorners = [
                        {x: 0, y: 0},
                        {x: slice.width, y: 0},
                        {x: slice.width, y: slice.height},
                        {x: 0, y: slice.height}
                    ];
                }

                // Draw lines connecting corners
                this.ctx.strokeStyle = '#FFA500';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for (let i = 0; i < slice.transformCorners.length; i++) {
                    const corner = slice.transformCorners[i];
                    const x = slice.x + corner.x;
                    const y = slice.y + corner.y;
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.closePath();
                this.ctx.stroke();

                // Draw corner handles
                this.ctx.fillStyle = '#FFA500';
                slice.transformCorners.forEach((corner, i) => {
                    const x = slice.x + corner.x;
                    const y = slice.y + corner.y;
                    this.ctx.fillRect(x - 8, y - 8, 16, 16);
                    
                    // Draw corner number
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(i + 1, x, y);
                    this.ctx.fillStyle = '#FFA500';
                });
            },

            rotateSlice(pos) {
                const slice = this.selectedSlice;
                if (slice.shape !== 'rectangle') return;
                
                const centerX = slice.x + slice.width / 2;
                const centerY = slice.y + slice.height / 2;
                let angle = Math.atan2(pos.y - centerY, pos.x - centerX) * 180 / Math.PI + 90;
                angle = angle % 360;
                
                // Snap to 0, 90, 180, 270 degrees if within 3 degrees
                const snapAngles = [0, 90, 180, 270, 360];
                for (let snapAngle of snapAngles) {
                    if (Math.abs(angle - snapAngle) < 3) {
                        angle = snapAngle % 360;
                        break;
                    }
                }
                
                // Round to 1 decimal place to avoid floating point errors
                slice.rotation = Math.round(angle * 10) / 10;
            },

            resizeSlice(pos) {
                const slice = this.selectedSlice;
                const h = this.resizeHandle;

                switch (h) {
                    case 'se':
                        slice.width = Math.max(10, pos.x - slice.x);
                        slice.height = Math.max(10, pos.y - slice.y);
                        break;
                    case 'sw':
                        const newW = slice.width + (slice.x - pos.x);
                        if (newW >= 10) {
                            slice.x = pos.x;
                            slice.width = newW;
                        }
                        slice.height = Math.max(10, pos.y - slice.y);
                        break;
                    case 'ne':
                        slice.width = Math.max(10, pos.x - slice.x);
                        const newH = slice.height + (slice.y - pos.y);
                        if (newH >= 10) {
                            slice.y = pos.y;
                            slice.height = newH;
                        }
                        break;
                    case 'nw':
                        const nw = slice.width + (slice.x - pos.x);
                        const nh = slice.height + (slice.y - pos.y);
                        if (nw >= 10 && nh >= 10) {
                            slice.x = pos.x;
                            slice.y = pos.y;
                            slice.width = nw;
                            slice.height = nh;
                        }
                        break;
                    case 'e': // East - change width only
                        slice.width = Math.max(10, pos.x - slice.x);
                        break;
                    case 'w': // West - change width only
                        const newWest = slice.width + (slice.x - pos.x);
                        if (newWest >= 10) {
                            slice.x = pos.x;
                            slice.width = newWest;
                        }
                        break;
                    case 's': // South - change height only
                        slice.height = Math.max(10, pos.y - slice.y);
                        break;
                    case 'n': // North - change height only
                        const newNorth = slice.height + (slice.y - pos.y);
                        if (newNorth >= 10) {
                            slice.y = pos.y;
                            slice.height = newNorth;
                        }
                        break;
                }
            },

            getResizeHandle(pos, slice) {
                if (slice.shape !== 'rectangle') return null;
                const handleSize = 10;
                
                // Corner handles
                const corners = {
                    'nw': { x: slice.x, y: slice.y },
                    'ne': { x: slice.x + slice.width, y: slice.y },
                    'sw': { x: slice.x, y: slice.y + slice.height },
                    'se': { x: slice.x + slice.width, y: slice.y + slice.height }
                };

                // Check corners first (priority)
                for (let [handle, hPos] of Object.entries(corners)) {
                    if (Math.abs(pos.x - hPos.x) < handleSize && Math.abs(pos.y - hPos.y) < handleSize) {
                        return handle;
                    }
                }
                
                // Edge handles (middle of each side)
                const edges = {
                    'n': { x: slice.x + slice.width / 2, y: slice.y },
                    's': { x: slice.x + slice.width / 2, y: slice.y + slice.height },
                    'e': { x: slice.x + slice.width, y: slice.y + slice.height / 2 },
                    'w': { x: slice.x, y: slice.y + slice.height / 2 }
                };
                
                for (let [handle, hPos] of Object.entries(edges)) {
                    if (Math.abs(pos.x - hPos.x) < handleSize && Math.abs(pos.y - hPos.y) < handleSize) {
                        return handle;
                    }
                }
                
                return null;
            },

            getSliceAt(pos) {
                // Check masks first (they're on top)
                for (let i = this.slices.length - 1; i >= 0; i--) {
                    const slice = this.slices[i];
                    if (slice.type === 'slice' && slice.masks && slice.masks.length > 0) {
                        for (let j = slice.masks.length - 1; j >= 0; j--) {
                            if (this.isPointInShape(pos, slice.masks[j])) {
                                return slice.masks[j];
                            }
                        }
                    }
                }
                // Then check slices
                for (let i = this.slices.length - 1; i >= 0; i--) {
                    if (this.isPointInShape(pos, this.slices[i])) {
                        return this.slices[i];
                    }
                }
                return null;
            },

            isPointInShape(pos, shape) {
                if (shape.shape === 'rectangle') {
                    return pos.x >= shape.x && pos.x <= shape.x + shape.width &&
                           pos.y >= shape.y && pos.y <= shape.y + shape.height;
                } else if (shape.shape === 'circle') {
                    const dx = pos.x - shape.centerX;
                    const dy = pos.y - shape.centerY;
                    return (dx * dx + dy * dy) <= (shape.radius * shape.radius);
                } else if (shape.points && shape.points.length > 0) {
                    // Point in polygon
                    let inside = false;
                    for (let i = 0, j = shape.points.length - 1; i < shape.points.length; j = i++) {
                        const xi = shape.points[i].x, yi = shape.points[i].y;
                        const xj = shape.points[j].x, yj = shape.points[j].y;
                        const intersect = ((yi > pos.y) !== (yj > pos.y)) &&
                            (pos.x < (xj - xi) * (pos.y - yi) / (yj - yi) + xi);
                        if (intersect) inside = !inside;
                    }
                    return inside;
                }
                return false;
            },

            render() {
                this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

                // Draw alignment guides if dragging or resizing
                if ((this.isDragging || this.isResizing) && this.selectedSlice && this.selectedSlice.shape === 'rectangle') {
                    const slice = this.selectedSlice;
                    const centerX = slice.x + slice.width / 2;
                    const centerY = slice.y + slice.height / 2;
                    const snapThreshold = 10;
                    
                    // Quarter points
                    const quarterX = this.canvasWidth / 4;
                    const halfX = this.canvasWidth / 2;
                    const threeQuarterX = this.canvasWidth * 3 / 4;
                    const quarterY = this.canvasHeight / 4;
                    const halfY = this.canvasHeight / 2;
                    const threeQuarterY = this.canvasHeight * 3 / 4;
                    
                    const verticalGuides = [];
                    const horizontalGuides = [];
                    
                    // Check center alignment
                    if (Math.abs(centerX - quarterX) < snapThreshold) verticalGuides.push(quarterX);
                    if (Math.abs(centerX - halfX) < snapThreshold) verticalGuides.push(halfX);
                    if (Math.abs(centerX - threeQuarterX) < snapThreshold) verticalGuides.push(threeQuarterX);
                    
                    if (Math.abs(centerY - quarterY) < snapThreshold) horizontalGuides.push(quarterY);
                    if (Math.abs(centerY - halfY) < snapThreshold) horizontalGuides.push(halfY);
                    if (Math.abs(centerY - threeQuarterY) < snapThreshold) horizontalGuides.push(threeQuarterY);
                    
                    // Check edge alignment when resizing
                    if (this.isResizing) {
                        // Check left and right edges
                        [quarterX, halfX, threeQuarterX].forEach(guide => {
                            if (Math.abs(slice.x - guide) < snapThreshold || 
                                Math.abs(slice.x + slice.width - guide) < snapThreshold) {
                                if (!verticalGuides.includes(guide)) verticalGuides.push(guide);
                            }
                        });
                        // Check top and bottom edges
                        [quarterY, halfY, threeQuarterY].forEach(guide => {
                            if (Math.abs(slice.y - guide) < snapThreshold || 
                                Math.abs(slice.y + slice.height - guide) < snapThreshold) {
                                if (!horizontalGuides.includes(guide)) horizontalGuides.push(guide);
                            }
                        });
                    }
                    
                    // Draw guides
                    if (verticalGuides.length > 0 || horizontalGuides.length > 0) {
                        this.ctx.save();
                        this.ctx.strokeStyle = '#FFC107';
                        this.ctx.lineWidth = 1;
                        this.ctx.setLineDash([5, 5]);
                        
                        verticalGuides.forEach(x => {
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, 0);
                            this.ctx.lineTo(x, this.canvasHeight);
                            this.ctx.stroke();
                        });
                        
                        horizontalGuides.forEach(y => {
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, y);
                            this.ctx.lineTo(this.canvasWidth, y);
                            this.ctx.stroke();
                        });
                        
                        this.ctx.restore();
                    }
                }

                // Draw temp shape
                if (this.drawingMode && this.tempShape) {
                    this.ctx.save();
                    this.ctx.strokeStyle = '#4CAF50';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.drawShapePath(this.tempShape, this.currentShape);
                    this.ctx.stroke();
                    this.ctx.restore();
                }

                // Draw points
                if (this.drawingMode && this.drawingPoints.length > 0) {
                    this.ctx.save();
                    this.ctx.strokeStyle = '#4CAF50';
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.lineWidth = 2;
                    
                    this.drawingPoints.forEach((p, i) => {
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        if (i > 0) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(this.drawingPoints[i-1].x, this.drawingPoints[i-1].y);
                            this.ctx.lineTo(p.x, p.y);
                            this.ctx.stroke();
                        }
                    });
                    this.ctx.restore();
                }

                // Draw all slices and their masks
                this.slices.forEach(slice => {
                    if (slice.type !== 'slice') return; // Only draw slices (masks are children)
                    if (slice.visible === false) return; // Skip hidden slices
                    
                    const isSelected = slice === this.selectedSlice;

                    this.ctx.save();

                    // Apply rotation for rectangles
                    if (slice.shape === 'rectangle' && slice.rotation) {
                        const centerX = slice.x + slice.width / 2;
                        const centerY = slice.y + slice.height / 2;
                        this.ctx.translate(centerX, centerY);
                        this.ctx.rotate(slice.rotation * Math.PI / 180);
                        this.ctx.translate(-centerX, -centerY);
                    }

                    // Draw slice fill
                    this.ctx.fillStyle = slice.color + '11';
                    this.drawShapePath(slice, slice.shape);
                    this.ctx.fill();

                    // Draw slice outline
                    this.ctx.strokeStyle = isSelected ? '#ffffff' : slice.color;
                    this.ctx.lineWidth = isSelected ? 3 : 2;
                    this.drawShapePath(slice, slice.shape);
                    this.ctx.stroke();

                    // Draw label
                    const labelPos = this.getShapeLabelPosition(slice);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 18px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'top';
                    this.ctx.fillText(slice.label, labelPos.x, labelPos.y);

                    this.ctx.restore();

                    // Draw masks for this slice
                    if (slice.masks && slice.masks.length > 0) {
                        slice.masks.forEach(mask => {
                            if (mask.visible === false) return; // Skip hidden masks
                            const isMaskSelected = mask === this.selectedSlice;
                            this.ctx.save();
                            
                            // Apply rotation for rectangles
                            if (mask.shape === 'rectangle' && mask.rotation) {
                                const centerX = mask.x + mask.width / 2;
                                const centerY = mask.y + mask.height / 2;
                                this.ctx.translate(centerX, centerY);
                                this.ctx.rotate(mask.rotation * Math.PI / 180);
                                this.ctx.translate(-centerX, -centerY);
                            }
                            
                            // Draw mask fill
                            this.ctx.fillStyle = '#ff000022';
                            this.drawShapePath(mask, mask.shape);
                            this.ctx.fill();
                            
                            // Hatch pattern
                            this.ctx.strokeStyle = '#ff0000';
                            this.ctx.lineWidth = 1;
                            this.ctx.save();
                            this.drawShapePath(mask, mask.shape);
                            this.ctx.clip();
                            
                            const bounds = this.getShapeBounds(mask);
                            for (let i = -bounds.width; i < bounds.width + bounds.height; i += 10) {
                                this.ctx.beginPath();
                                this.ctx.moveTo(bounds.x + i, bounds.y);
                                this.ctx.lineTo(bounds.x + i + bounds.height, bounds.y + bounds.height);
                                this.ctx.stroke();
                            }
                            this.ctx.restore();
                            
                            // Draw mask outline (thicker if selected)
                            this.ctx.strokeStyle = isMaskSelected ? '#ffffff' : '#ff0000';
                            this.ctx.lineWidth = isMaskSelected ? 3 : 2;
                            this.drawShapePath(mask, mask.shape);
                            this.ctx.stroke();
                            
                            // Draw mask label
                            const maskLabelPos = this.getShapeLabelPosition(mask);
                            this.ctx.fillStyle = isMaskSelected ? '#ffffff' : '#ff0000';
                            this.ctx.font = 'bold 16px Arial';
                            this.ctx.textAlign = 'left';
                            this.ctx.textBaseline = 'top';
                            this.ctx.fillText(mask.label, maskLabelPos.x, maskLabelPos.y);
                            
                            // Draw handles for selected mask (rectangles only)
                            if (isMaskSelected && mask.shape === 'rectangle') {
                                this.drawResizeHandles(mask);
                            }
                            
                            this.ctx.restore();
                        });
                    }

                    // Draw handles for selected slice
                    if (isSelected && slice.shape === 'rectangle') {
                        if (this.transformMode) {
                            this.drawTransformHandles(slice);
                        } else {
                            this.drawResizeHandles(slice);
                            this.drawRotationHandle(slice);
                        }
                    }
                });
            },

            drawShapePath(shape, shapeType) {
                const type = shapeType || shape.shape;
                this.ctx.beginPath();
                
                if (type === 'rectangle') {
                    const x = shape.x || 0;
                    const y = shape.y || 0;
                    const w = shape.width || 0;
                    const h = shape.height || 0;
                    if (w === 0 || h === 0) {
                        console.warn('Rectangle with zero dimensions:', shape);
                        return;
                    }
                    this.ctx.rect(x, y, w, h);
                } else if (type === 'circle') {
                    const cx = shape.centerX || 0;
                    const cy = shape.centerY || 0;
                    const r = shape.radius || 0;
                    if (r === 0) {
                        console.warn('Circle with zero radius:', shape);
                        return;
                    }
                    this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
                } else if (shape.points && shape.points.length > 0) {
                    this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                    for (let i = 1; i < shape.points.length; i++) {
                        this.ctx.lineTo(shape.points[i].x, shape.points[i].y);
                    }
                    this.ctx.closePath();
                } else {
                    console.warn('No valid shape data:', shape);
                }
            },

            getShapeBounds(shape) {
                if (shape.shape === 'rectangle') {
                    return { 
                        x: shape.x || 0, 
                        y: shape.y || 0, 
                        width: shape.width || 0, 
                        height: shape.height || 0 
                    };
                } else if (shape.shape === 'circle') {
                    const cx = shape.centerX || 0;
                    const cy = shape.centerY || 0;
                    const r = shape.radius || 0;
                    return {
                        x: cx - r,
                        y: cy - r,
                        width: r * 2,
                        height: r * 2
                    };
                } else if (shape.points && shape.points.length > 0) {
                    const xs = shape.points.map(p => p.x);
                    const ys = shape.points.map(p => p.y);
                    const minX = Math.min(...xs);
                    const maxX = Math.max(...xs);
                    const minY = Math.min(...ys);
                    const maxY = Math.max(...ys);
                    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
                }
                console.warn('Shape bounds not found for:', shape);
                return { x: 0, y: 0, width: 0, height: 0 };
            },

            getShapeLabelPosition(shape) {
                const bounds = this.getShapeBounds(shape);
                return { x: bounds.x + 5, y: bounds.y + 5 };
            },

            drawResizeHandles(slice) {
                // Corner handles
                const corners = [
                    [slice.x, slice.y],
                    [slice.x + slice.width, slice.y],
                    [slice.x, slice.y + slice.height],
                    [slice.x + slice.width, slice.y + slice.height]
                ];
                
                // Edge handles (middle of each side)
                const edges = [
                    [slice.x + slice.width / 2, slice.y], // North
                    [slice.x + slice.width / 2, slice.y + slice.height], // South
                    [slice.x + slice.width, slice.y + slice.height / 2], // East
                    [slice.x, slice.y + slice.height / 2] // West
                ];
                
                // Draw corner handles (larger, white)
                this.ctx.fillStyle = '#ffffff';
                corners.forEach(([x, y]) => {
                    this.ctx.fillRect(x - 6, y - 6, 12, 12);
                });
                
                // Draw edge handles (smaller, blue)
                this.ctx.fillStyle = '#2196F3';
                edges.forEach(([x, y]) => {
                    this.ctx.fillRect(x - 5, y - 5, 10, 10);
                });
            },

            drawRotationHandle(slice) {
                const centerX = slice.x + slice.width / 2;
                const rotHandleY = slice.y - 30;
                
                // Draw line from top center to rotation handle
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#4CAF50';
                this.ctx.lineWidth = 2;
                this.ctx.moveTo(centerX, slice.y);
                this.ctx.lineTo(centerX, rotHandleY);
                this.ctx.stroke();
                
                // Draw rotation handle circle
                this.ctx.beginPath();
                this.ctx.arc(centerX, rotHandleY, 12, 0, Math.PI * 2);
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.fill();
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // Draw rotation icon
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                this.ctx.arc(centerX, rotHandleY, 4, 0.5, Math.PI * 1.5);
                this.ctx.stroke();
            },

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: (e.clientX - rect.left) / (this.scale * this.canvasZoom),
                    y: (e.clientY - rect.top) / (this.scale * this.canvasZoom)
                };
            },

            updateCanvasSize() {
                this.canvasWidth = parseInt(document.getElementById('canvasWidth').value);
                this.canvasHeight = parseInt(document.getElementById('canvasHeight').value);

                const container = document.getElementById('canvasContainer');
                const maxWidth = container.parentElement.clientWidth - 40;
                const maxHeight = container.parentElement.clientHeight - 40;
                
                const scaleX = maxWidth / this.canvasWidth;
                const scaleY = maxHeight / this.canvasHeight;
                this.scale = Math.min(scaleX, scaleY, 1);

                const displayWidth = this.canvasWidth * this.scale;
                const displayHeight = this.canvasHeight * this.scale;

                this.canvas.width = this.canvasWidth;
                this.canvas.height = this.canvasHeight;
                this.canvas.style.width = displayWidth + 'px';
                this.canvas.style.height = displayHeight + 'px';

                this.videoCanvas.width = this.canvasWidth;
                this.videoCanvas.height = this.canvasHeight;
                this.videoCanvas.style.width = displayWidth + 'px';
                this.videoCanvas.style.height = displayHeight + 'px';

                container.style.width = displayWidth + 'px';
                container.style.height = displayHeight + 'px';

                document.getElementById('canvasDimensions').textContent = `${this.canvasWidth}x${this.canvasHeight}`;

                this.drawTestPattern();
                this.render();
            },

            drawTestPattern() {
                const ctx = this.videoCtx;
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 1;
                const gridSize = 100;
                
                for (let x = 0; x <= this.canvasWidth; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.canvasHeight);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= this.canvasHeight; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.canvasWidth, y);
                    ctx.stroke();
                }

                ctx.fillStyle = '#444';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('VIDEO CANVAS', this.canvasWidth / 2, this.canvasHeight / 2);
            },

            deleteSelected() {
                if (this.selectedSlice) {
                    // Check if selected item is a mask
                    let isMask = false;
                    for (let slice of this.slices) {
                        if (slice.masks && slice.masks.includes(this.selectedSlice)) {
                            slice.masks = slice.masks.filter(m => m !== this.selectedSlice);
                            isMask = true;
                            this.showToast('Mask deleted');
                            break;
                        }
                    }
                    
                    // If not a mask, delete slice
                    if (!isMask) {
                        this.slices = this.slices.filter(s => s !== this.selectedSlice);
                        this.showToast('Shape deleted');
                    }
                    
                    this.selectedSlice = null;
                    this.updateUI();
                    this.render();
                    this.saveToLocalStorage();
                }
            },

            duplicateSelected() {
                if (!this.selectedSlice) return;
                
                // Check if selected item is a mask
                let isMask = false;
                let parentSlice = null;
                for (let slice of this.slices) {
                    if (slice.masks && slice.masks.includes(this.selectedSlice)) {
                        isMask = true;
                        parentSlice = slice;
                        break;
                    }
                }
                
                if (isMask && parentSlice) {
                    // Duplicate mask
                    const mask = this.selectedSlice;
                    const duplicate = JSON.parse(JSON.stringify(mask));
                    duplicate.id = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    duplicate.label = mask.label + ' Copy';
                    
                    // Offset position
                    if (duplicate.shape === 'rectangle') {
                        duplicate.x += 20;
                        duplicate.y += 20;
                    } else if (duplicate.shape === 'circle') {
                        duplicate.centerX += 20;
                        duplicate.centerY += 20;
                    } else if (duplicate.points) {
                        duplicate.points = duplicate.points.map(p => ({x: p.x + 20, y: p.y + 20}));
                    }
                    
                    parentSlice.masks.push(duplicate);
                    this.selectedSlice = duplicate;
                    this.showToast('Mask duplicated');
                } else if (this.selectedSlice.type === 'slice') {
                    // Duplicate slice
                    const slice = this.selectedSlice;
                    const duplicate = JSON.parse(JSON.stringify(slice));
                    duplicate.id = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    duplicate.label = slice.label + ' Copy';
                    
                    // Offset position
                    if (duplicate.shape === 'rectangle') {
                        duplicate.x += 20;
                        duplicate.y += 20;
                    } else if (duplicate.shape === 'circle') {
                        duplicate.centerX += 20;
                        duplicate.centerY += 20;
                    } else if (duplicate.points) {
                        duplicate.points = duplicate.points.map(p => ({x: p.x + 20, y: p.y + 20}));
                    }
                    
                    // Duplicate masks with new IDs
                    if (duplicate.masks && duplicate.masks.length > 0) {
                        duplicate.masks = duplicate.masks.map(m => {
                            const newMask = JSON.parse(JSON.stringify(m));
                            newMask.id = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                            return newMask;
                        });
                    }
                    
                    this.slices.push(duplicate);
                    this.selectedSlice = duplicate;
                    this.showToast('Slice duplicated');
                }
                
                this.updateUI();
                this.render();
                this.saveToLocalStorage();
            },

            toggleSnap() {
                this.snapToGrid = !this.snapToGrid;
                document.getElementById('snapBtn').textContent = `üìê Snap: ${this.snapToGrid ? 'ON' : 'OFF'}`;
            },

            toggleTransformMode() {
                this.transformMode = !this.transformMode;
                const btn = document.getElementById('transformBtn');
                if (this.transformMode) {
                    btn.style.background = '#2a4a2a';
                    btn.style.borderColor = '#4CAF50';
                    this.showToast('Transform mode: Drag corners to move them independently');
                } else {
                    btn.style.background = '';
                    btn.style.borderColor = '';
                }
                this.render();
            },

            showPreview() {
                if (!this.selectedSlice) {
                    this.showToast('Select a slice first', 'error');
                    return;
                }

                const modal = document.getElementById('previewModal');
                const canvas = document.getElementById('previewCanvas');
                const ctx = canvas.getContext('2d');
                const infoDiv = document.getElementById('previewInfo');

                const slice = this.selectedSlice;
                
                // Update modal title with slice name
                const modalTitle = modal.querySelector('.preview-header h3');
                modalTitle.textContent = `Slice Preview - ${slice.label}`;
                
                // Determine slice bounds
                let bounds;
                if (slice.shape === 'rectangle') {
                    bounds = { x: slice.x, y: slice.y, width: slice.width, height: slice.height };
                } else {
                    bounds = this.getShapeBounds(slice);
                }

                // Scale to fit max 800x600
                const maxWidth = 800;
                const maxHeight = 600;
                const scale = Math.min(maxWidth / bounds.width, maxHeight / bounds.height, 1);
                
                canvas.width = bounds.width * scale;
                canvas.height = bounds.height * scale;
                canvas.style.width = canvas.width + 'px';
                canvas.style.height = canvas.height + 'px';

                // Draw scaled slice preview
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.scale(scale, scale);
                ctx.translate(-bounds.x, -bounds.y);

                // Apply rotation if rectangle
                if (slice.shape === 'rectangle' && slice.rotation) {
                    const centerX = slice.x + slice.width / 2;
                    const centerY = slice.y + slice.height / 2;
                    ctx.translate(centerX, centerY);
                    ctx.rotate(slice.rotation * Math.PI / 180);
                    ctx.translate(-centerX, -centerY);
                }

                // Draw slice shape
                ctx.fillStyle = slice.color + '44';
                this.drawShapePath(slice, slice.shape);
                ctx.fill();

                ctx.strokeStyle = slice.color;
                ctx.lineWidth = 3;
                this.drawShapePath(slice, slice.shape);
                ctx.stroke();

                // Draw masks
                if (slice.masks && slice.masks.length > 0) {
                    slice.masks.forEach(mask => {
                        // Apply rotation if rectangle mask
                        if (mask.shape === 'rectangle' && mask.rotation) {
                            const centerX = mask.x + mask.width / 2;
                            const centerY = mask.y + mask.height / 2;
                            ctx.translate(centerX, centerY);
                            ctx.rotate(mask.rotation * Math.PI / 180);
                            ctx.translate(-centerX, -centerY);
                        }

                        ctx.fillStyle = '#ff000044';
                        this.drawShapePath(mask, mask.shape);
                        ctx.fill();

                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                        this.drawShapePath(mask, mask.shape);
                        ctx.stroke();
                    });
                }

                ctx.restore();

                // Update info
                const isMask = slice.type === 'mask';
                infoDiv.innerHTML = `
                    <div class="preview-info-row">
                        <span class="preview-info-label">Type:</span>
                        <span>${isMask ? 'Mask' : 'Slice'}</span>
                    </div>
                    <div class="preview-info-row">
                        <span class="preview-info-label">Label:</span>
                        <span>${slice.label}</span>
                    </div>
                    <div class="preview-info-row">
                        <span class="preview-info-label">Shape:</span>
                        <span>${slice.shape}</span>
                    </div>
                    <div class="preview-info-row">
                        <span class="preview-info-label">Position:</span>
                        <span>${Math.round(bounds.x)}, ${Math.round(bounds.y)}</span>
                    </div>
                    <div class="preview-info-row">
                        <span class="preview-info-label">Size:</span>
                        <span>${Math.round(bounds.width)} x ${Math.round(bounds.height)}</span>
                    </div>
                    ${slice.rotation ? `
                    <div class="preview-info-row">
                        <span class="preview-info-label">Rotation:</span>
                        <span>${Math.round(slice.rotation)}¬∞</span>
                    </div>` : ''}
                    ${slice.screens ? `
                    <div class="preview-info-row">
                        <span class="preview-info-label">Outputs:</span>
                        <span>${slice.screens.join(', ')}</span>
                    </div>` : ''}
                    ${slice.masks && slice.masks.length > 0 ? `
                    <div class="preview-info-row">
                        <span class="preview-info-label">Masks:</span>
                        <span>${slice.masks.length}</span>
                    </div>` : ''}
                    <div class="preview-info-row">
                        <span class="preview-info-label">Scale:</span>
                        <span>${Math.round(scale * 100)}%</span>
                    </div>
                `;

                modal.classList.add('active');
            },

            closePreview() {
                const modal = document.getElementById('previewModal');
                modal.classList.remove('active');
            },

            zoomIn() {
                this.canvasZoom = Math.min(this.canvasZoom * 1.2, 5.0);
                this.updateCanvasZoom();
            },

            zoomOut() {
                this.canvasZoom = Math.max(this.canvasZoom / 1.2, 0.2);
                this.updateCanvasZoom();
            },

            resetZoom() {
                this.canvasZoom = 1.0;
                this.updateCanvasZoom();
            },

            updateCanvasZoom() {
                const container = document.getElementById('canvasContainer');
                
                // Calculate display size considering both scale and zoom
                const displayWidth = this.canvasWidth * this.scale;
                const displayHeight = this.canvasHeight * this.scale;
                
                // Apply zoom transform to both canvases
                this.canvas.style.transform = `scale(${this.canvasZoom})`;
                this.canvas.style.transformOrigin = 'top left';
                this.videoCanvas.style.transform = `scale(${this.canvasZoom})`;
                this.videoCanvas.style.transformOrigin = 'top left';
                
                // Update container size to accommodate zoomed canvas
                const scaledWidth = displayWidth * this.canvasZoom;
                const scaledHeight = displayHeight * this.canvasZoom;
                container.style.width = scaledWidth + 'px';
                container.style.height = scaledHeight + 'px';
                
                // Update zoom display
                document.getElementById('zoomLevel').textContent = Math.round(this.canvasZoom * 100) + '%';
            },

            toggleScreen(screen) {
                if (this.selectedSlice && this.selectedSlice.type === 'slice') {
                    const screens = this.selectedSlice.screens || [];
                    const index = screens.indexOf(screen);
                    if (index > -1) {
                        screens.splice(index, 1);
                        this.showToast(`Removed from ${screen}`);
                    } else {
                        screens.push(screen);
                        this.showToast(`Assigned to ${screen}`);
                    }
                    this.selectedSlice.screens = screens;
                    this.updateUI();
                    this.saveToLocalStorage();
                } else {
                    this.showToast('Select a slice (not mask) to assign outputs', 'error');
                }
            },

            addOutput() {
                const name = prompt('Output screen name:');
                if (name && !this.screens.includes(name) && !this.customScreens.includes(name)) {
                    this.customScreens.push(name);
                    this.updateScreenButtons();
                    this.saveToLocalStorage();
                    this.showToast(`Added output: ${name}`);
                }
            },

            updateScreenButtons() {
                const container = document.getElementById('screenButtonsContainer');
                const allScreens = [...this.screens, ...this.customScreens];
                const selectedScreens = (this.selectedSlice && this.selectedSlice.type === 'slice') ? (this.selectedSlice.screens || []) : [];
                const disabled = (!this.selectedSlice || this.selectedSlice.type !== 'slice') ? 'disabled' : '';
                
                let html = '';
                this.screens.forEach(screen => {
                    const displayName = screen === 'Virtual' ? 'Virtual (Dummy)' : screen;
                    const checked = selectedScreens.includes(screen) ? 'checked' : '';
                    html += `
                        <div class="screen-checkbox-item ${disabled}">
                            <input type="checkbox" id="screen_${screen}" ${checked} ${disabled ? 'disabled' : ''}
                                   onchange="app.toggleScreen('${screen}')">
                            <label for="screen_${screen}">${displayName}</label>
                        </div>
                    `;
                });
                
                this.customScreens.forEach(screen => {
                    const checked = selectedScreens.includes(screen) ? 'checked' : '';
                    html += `
                        <div style="display: flex; gap: 5px;">
                            <div class="screen-checkbox-item ${disabled}" style="flex: 1;">
                                <input type="checkbox" id="screen_${screen}" ${checked} ${disabled ? 'disabled' : ''}
                                       onchange="app.toggleScreen('${screen}')">
                                <label for="screen_${screen}">${screen}</label>
                            </div>
                            <button onclick="app.removeOutput('${screen}')" style="padding: 8px;">√ó</button>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            },

            removeOutput(screen) {
                if (confirm(`Remove "${screen}"?`)) {
                    this.slices.forEach(s => {
                        const screens = s.screens || [];
                        const index = screens.indexOf(screen);
                        if (index > -1) screens.splice(index, 1);
                        if (screens.length === 0) screens.push('HDMI1');
                        s.screens = screens;
                    });
                    this.customScreens = this.customScreens.filter(s => s !== screen);
                    this.updateScreenButtons();
                    this.updateUI();
                    this.saveToLocalStorage();
                }
            },

            updateUI() {
                const sliceCount = this.slices.filter(s => s.type === 'slice').length;
                document.getElementById('sliceCount').textContent = sliceCount;
                document.getElementById('selectedSlice').textContent = 
                    this.selectedSlice ? this.selectedSlice.label : 'None';

                this.updateScreenButtons();

                const allScreens = [...this.screens, ...this.customScreens];
                const slicesByScreen = {};
                allScreens.forEach(screen => {
                    slicesByScreen[screen] = this.slices.filter(s => {
                        if (s.type !== 'slice') return false;
                        const screens = s.screens || ['HDMI1'];
                        return screens.includes(screen);
                    });
                });

                let listHtml = '';
                allScreens.forEach(screen => {
                    const slices = slicesByScreen[screen];
                    const displayName = screen === 'Virtual' ? 'Virtual (Dummy)' : screen;
                    listHtml += `
                        <div class="screen-group">
                            <div class="screen-group-header">
                                <strong>${displayName}</strong>
                                <span style="color: #888;">${slices.length} slices</span>
                            </div>
                    `;

                    if (slices.length === 0) {
                        listHtml += '<div style="color: #666; font-size: 12px; padding: 8px;">No slices</div>';
                    } else {
                        slices.forEach(slice => {
                            const isActive = slice === this.selectedSlice ? 'active' : '';
                            const shapeScreens = slice.screens || [];
                            const badge = shapeScreens.length > 1 ? 
                                `<span style="background: #4CAF50; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">${shapeScreens.length} outputs</span>` : '';
                            const maskCount = slice.masks ? slice.masks.length : 0;
                            const maskBadge = maskCount > 0 ? 
                                `<span style="background: #f44336; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">${maskCount} masks</span>` : '';
                            
                            listHtml += `
                                <div class="slice-item ${isActive}" onclick="app.selectSlice('${slice.id}')">
                                    <div class="slice-item-header">
                                        <div style="display: flex; align-items: center; gap: 5px; flex-wrap: wrap;">
                                            <span style="color: #4CAF50">‚úì</span>
                                            <span class="slice-color-indicator" style="background: ${slice.color}"></span>
                                            <input type="text" value="${slice.label}" onchange="app.updateProperty('${slice.id}', 'label', this.value); event.stopPropagation();" onclick="event.stopPropagation();" style="background: transparent; border: none; color: #fff; font-size: 14px; padding: 2px 4px; width: 150px; border-bottom: 1px solid transparent;" onfocus="this.style.borderBottomColor='#4CAF50'" onblur="this.style.borderBottomColor='transparent'">
                                            ${badge}
                                            ${maskBadge}
                                        </div>
                                        <div class="slice-item-actions">
                                            <button class="small" onclick="app.toggleVisibility('${slice.id}'); event.stopPropagation();" style="padding: 4px 8px; font-size: 12px;">${slice.visible !== false ? 'üëÅÔ∏è' : 'üö´'}</button>
                                            <button class="small danger" onclick="app.deleteSliceById('${slice.id}'); event.stopPropagation();" style="padding: 4px 8px; font-size: 10px;">Del</button>
                                        </div>
                                    </div>
                                    <div class="slice-item-info">
                                        <span>${slice.shape}</span>
                                    </div>
                                </div>
                            `;
                            
                            // Show property editor for selected slice
                            if (isActive && slice.shape === 'rectangle') {
                                listHtml += `
                                    <div style="padding: 10px; background: #1a1a1a; border-radius: 4px; margin-top: 8px;">
                                        <div style="font-size: 11px; color: #888; margin-bottom: 8px;">Properties:</div>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                                            <div>
                                                <label style="font-size: 10px; color: #666;">X</label>
                                                <input type="number" value="${Math.round(slice.x)}" onchange="app.updateProperty('${slice.id}', 'x', parseFloat(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div>
                                                <label style="font-size: 10px; color: #666;">Y</label>
                                                <input type="number" value="${Math.round(slice.y)}" onchange="app.updateProperty('${slice.id}', 'y', parseFloat(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div>
                                                <label style="font-size: 10px; color: #666;">Width</label>
                                                <input type="number" value="${Math.round(slice.width)}" onchange="app.updateProperty('${slice.id}', 'width', parseFloat(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div>
                                                <label style="font-size: 10px; color: #666;">Height</label>
                                                <input type="number" value="${Math.round(slice.height)}" onchange="app.updateProperty('${slice.id}', 'height', parseFloat(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div style="grid-column: 1 / -1;">
                                                <label style="font-size: 10px; color: #666;">Rotation (¬∞)</label>
                                                <input type="number" value="${Math.round(slice.rotation || 0)}" onchange="app.updateProperty('${slice.id}', 'rotation', parseFloat(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div>
                                                <label style="font-size: 10px; color: #666;">Brightness (-100-100)</label>
                                                <input type="number" min="-100" max="100" value="${slice.brightness || 0}" onchange="app.updateProperty('${slice.id}', 'brightness', parseInt(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div>
                                                <label style="font-size: 10px; color: #666;">Contrast (-100-100)</label>
                                                <input type="number" min="-100" max="100" value="${slice.contrast || 0}" onchange="app.updateProperty('${slice.id}', 'contrast', parseInt(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div>
                                                <label style="font-size: 10px; color: #666;">Red (-255-255)</label>
                                                <input type="number" min="-255" max="255" value="${slice.red || 0}" onchange="app.updateProperty('${slice.id}', 'red', parseInt(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div>
                                                <label style="font-size: 10px; color: #666;">Green (-255-255)</label>
                                                <input type="number" min="-255" max="255" value="${slice.green || 0}" onchange="app.updateProperty('${slice.id}', 'green', parseInt(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div>
                                                <label style="font-size: 10px; color: #666;">Blue (-255-255)</label>
                                                <input type="number" min="-255" max="255" value="${slice.blue || 0}" onchange="app.updateProperty('${slice.id}', 'blue', parseInt(this.value))" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                            </div>
                                            <div>
                                                <label style="font-size: 10px; color: #666;">Mirror/Flip</label>
                                                <select value="${slice.mirror || 'none'}" onchange="app.updateProperty('${slice.id}', 'mirror', this.value)" style="width: 100%; padding: 4px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 3px;">
                                                    <option value="none" ${(slice.mirror || 'none') === 'none' ? 'selected' : ''}>None</option>
                                                    <option value="horizontal" ${slice.mirror === 'horizontal' ? 'selected' : ''}>Horizontal</option>
                                                    <option value="vertical" ${slice.mirror === 'vertical' ? 'selected' : ''}>Vertical</option>
                                                    <option value="both" ${slice.mirror === 'both' ? 'selected' : ''}>Both</option>
                                                </select>
                                            </div>
                                            <div style="grid-column: 1 / -1;">
                                                <label style="font-size: 10px; color: #666; display: flex; align-items: center; gap: 8px;">
                                                    <input type="checkbox" ${slice.softEdge ? 'checked' : ''} onchange="app.updateProperty('${slice.id}', 'softEdge', this.checked)" style="width: auto;">
                                                    Soft Edge
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }

                            // Show masks under the slice
                            if (slice.masks && slice.masks.length > 0) {
                                slice.masks.forEach(mask => {
                                    const isMaskActive = mask === this.selectedSlice ? 'active' : '';
                                    listHtml += `
                                        <div style="padding-left: 20px; margin-top: 4px;">
                                            <div class="slice-item ${isMaskActive}" style="background: #1a1a1a; border-color: #f44336;" onclick="app.selectMask('${slice.id}', '${mask.id}'); event.stopPropagation();">
                                                <div class="slice-item-header">
                                                    <div style="display: flex; align-items: center; gap: 5px;">
                                                        <span style="color: #f44336">‚Ü≥ ‚úï</span>
                                                        <input type="text" value="${mask.label}" onchange="app.updateMaskProperty('${slice.id}', '${mask.id}', 'label', this.value); event.stopPropagation();" onclick="event.stopPropagation();" style="background: transparent; border: none; color: #fff; font-size: 12px; padding: 2px 4px; width: 120px; border-bottom: 1px solid transparent;" onfocus="this.style.borderBottomColor='#f44336'" onblur="this.style.borderBottomColor='transparent'">
                                                    </div>
                                                    <div class="slice-item-actions">
                                                        <button class="small" onclick="app.toggleMaskVisibility('${slice.id}', '${mask.id}'); event.stopPropagation();" style="padding: 4px 8px; font-size: 12px;">${mask.visible !== false ? 'üëÅÔ∏è' : 'üö´'}</button>
                                                        <button class="small danger" onclick="app.deleteMask('${slice.id}', '${mask.id}'); event.stopPropagation();" style="padding: 4px 8px; font-size: 10px;">Del</button>
                                                    </div>
                                                </div>
                                                <div class="slice-item-info">
                                                    <span style="font-size: 10px;">${mask.shape}</span>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                });
                            }
                        });
                    }
                    listHtml += '</div>';
                });

                document.getElementById('slicesList').innerHTML = listHtml;
            },

            selectSlice(id) {
                this.selectedSlice = this.slices.find(s => s.id === id) || null;
                this.updateUI();
                this.render();
            },

            selectMask(sliceId, maskId) {
                const slice = this.slices.find(s => s.id === sliceId);
                if (slice && slice.masks) {
                    this.selectedSlice = slice.masks.find(m => m.id === maskId) || null;
                    this.updateUI();
                    this.render();
                }
            },

            deleteMask(sliceId, maskId) {
                const slice = this.slices.find(s => s.id === sliceId);
                if (slice && slice.masks) {
                    slice.masks = slice.masks.filter(m => m.id !== maskId);
                    if (this.selectedSlice && this.selectedSlice.id === maskId) {
                        this.selectedSlice = null;
                    }
                    this.updateUI();
                    this.render();
                    this.saveToLocalStorage();
                    this.showToast('Mask deleted');
                }
            },

            deleteSliceById(id) {
                this.slices = this.slices.filter(s => s.id !== id);
                if (this.selectedSlice && this.selectedSlice.id === id) {
                    this.selectedSlice = null;
                }
                this.updateUI();
                this.render();
                this.saveToLocalStorage();
                this.showToast('Slice deleted');
            },

            toggleVisibility(id) {
                const slice = this.slices.find(s => s.id === id);
                if (slice) {
                    slice.visible = slice.visible === false ? true : false;
                    this.updateUI();
                    this.render();
                    this.saveToLocalStorage();
                }
            },

            toggleMaskVisibility(sliceId, maskId) {
                const slice = this.slices.find(s => s.id === sliceId);
                if (slice && slice.masks) {
                    const mask = slice.masks.find(m => m.id === maskId);
                    if (mask) {
                        mask.visible = mask.visible === false ? true : false;
                        this.updateUI();
                        this.render();
                        this.saveToLocalStorage();
                    }
                }
            },

            updateProperty(id, property, value) {
                const slice = this.slices.find(s => s.id === id);
                if (slice) {
                    if (property === 'label') {
                        slice[property] = value;
                    } else if (!isNaN(value)) {
                        slice[property] = value;
                    }
                    this.updateUI();
                    this.render();
                    this.saveToLocalStorage();
                }
            },

            updateMaskProperty(sliceId, maskId, property, value) {
                const slice = this.slices.find(s => s.id === sliceId);
                if (slice && slice.masks) {
                    const mask = slice.masks.find(m => m.id === maskId);
                    if (mask) {
                        if (property === 'label') {
                            mask[property] = value;
                        } else if (!isNaN(value)) {
                            mask[property] = value;
                        }
                        this.updateUI();
                        this.render();
                        this.saveToLocalStorage();
                    }
                }
            },

            exportJSON() {
                const data = {
                    version: '2.0',
                    canvas: { width: this.canvasWidth, height: this.canvasHeight },
                    customScreens: this.customScreens,
                    slices: this.slices.filter(s => s.type === 'slice').map(s => {
                        const sliceData = {
                            id: s.id,
                            label: s.label,
                            type: s.type,
                            shape: s.shape,
                            screens: s.screens || [],
                            color: s.color,
                            ...this.getShapeData(s)
                        };
                        
                        // Add masks if any
                        if (s.masks && s.masks.length > 0) {
                            sliceData.masks = s.masks.map(m => ({
                                id: m.id,
                                label: m.label,
                                type: m.type,
                                shape: m.shape,
                                color: m.color,
                                ...this.getShapeData(m)
                            }));
                        }
                        
                        return sliceData;
                    }),
                    timestamp: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `slices_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                this.showToast('Exported!');
            },

            getShapeData(shape) {
                if (shape.shape === 'rectangle') {
                    return { x: shape.x, y: shape.y, width: shape.width, height: shape.height };
                } else if (shape.shape === 'circle') {
                    return { centerX: shape.centerX, centerY: shape.centerY, radius: shape.radius };
                } else {
                    return { points: shape.points || [] };
                }
            },

            importJSON(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (data.canvas) {
                                this.canvasWidth = data.canvas.width;
                                this.canvasHeight = data.canvas.height;
                                document.getElementById('canvasWidth').value = this.canvasWidth;
                                document.getElementById('canvasHeight').value = this.canvasHeight;
                            }
                            if (data.customScreens) {
                                this.customScreens = data.customScreens;
                            }
                            if (data.slices) {
                                this.slices = data.slices;
                            }
                            this.selectedSlice = null;
                            this.updateCanvasSize();
                            this.updateScreenButtons();
                            this.updateUI();
                            this.render();
                            this.saveToLocalStorage();
                            this.showToast('Imported!');
                        } catch (err) {
                            this.showToast('Import failed', 'error');
                        }
                    };
                    reader.readAsText(file);
                }
                event.target.value = '';
            },

            clearAll() {
                if (confirm('Clear all shapes?')) {
                    this.slices = [];
                    this.selectedSlice = null;
                    this.updateUI();
                    this.render();
                    this.saveToLocalStorage();
                    this.showToast('Cleared');
                }
            },

            saveToLocalStorage() {
                try {
                    localStorage.setItem('sliceEditor', JSON.stringify({
                        canvas: { width: this.canvasWidth, height: this.canvasHeight },
                        slices: this.slices,
                        customScreens: this.customScreens
                    }));
                } catch (e) {}
            },

            loadFromLocalStorage() {
                try {
                    const data = JSON.parse(localStorage.getItem('sliceEditor'));
                    if (data) {
                        if (data.canvas) {
                            this.canvasWidth = data.canvas.width;
                            this.canvasHeight = data.canvas.height;
                        }
                        if (data.slices) this.slices = data.slices;
                        if (data.customScreens) this.customScreens = data.customScreens;
                    }
                } catch (e) {}
            },

            togglePanel(side) {
                const panel = document.getElementById(side === 'left' ? 'rightPanel' : 'leftPanel');
                const toggle = panel.querySelector('.panel-toggle');
                panel.classList.toggle('collapsed');
                
                if (side === 'left') {
                    toggle.textContent = panel.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
                } else {
                    toggle.textContent = panel.classList.contains('collapsed') ? '‚óÄ' : '‚ñ∂';
                }
            },

            showToast(message, type = 'success') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            }
        };

        // Make app globally accessible
        window.app = app;

        window.addEventListener('load', () => app.init());
    </script>
</body>
</html>
